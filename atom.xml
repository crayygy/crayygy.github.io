<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[渐行渐远]]></title>
  <link href="http://blog.crayygy.com/atom.xml" rel="self"/>
  <link href="http://blog.crayygy.com/"/>
  <updated>2017-01-13T00:29:04+08:00</updated>
  <id>http://blog.crayygy.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Some Mongodb problems and solutions]]></title>
    <link href="http://blog.crayygy.com/14842384827556.html"/>
    <updated>2017-01-13T00:28:02+08:00</updated>
    <id>http://blog.crayygy.com/14842384827556.html</id>
    <content type="html"><![CDATA[
<p>Recently I have encountered some problems during my internship. One of our server suddenly goes very very slow, when I try to ping the server, it&#39;s always 2000-5000. After checked everything I think may cause the problem and got no answer, I decided to reboot the server.</p>

<span id="more"></span><!-- more -->

<p>After hard reboot the virtual machine, it&#39;s just the start of the hell. First, I found there&#39;s some warning about ruby, then, the mongodb on the server can&#39;t restart after reboot. </p>

<p>Luckily, we have already backup our data since one time that we delete our database without &quot;where&quot;.  We backup our database every two hours to another server. So nothing too bad happens.</p>

<p>Mongodb is such a nasty guy, when I try to restart with ⌘ <code>mongod -f /etc/mongod.conf --fork</code>, it got stuck. And never showed a single message. At last, I had to delete my exist db and pull it back from our backup server, and then put it into another folder, and re-write the config file, change dbpath parameter, and start with ⌘ <code>mongod -f /etc/mongod.conf --fork</code>.</p>

<p>Something good about mongo is that it can set a master db and a slave db for backup.  For this, all you have to do is start mongo with a config file, and set <code>master=true</code> or <code>slave=true</code> in config file.</p>

<p>For example, on you master db server, you should write config file like this:</p>

<pre><code>dbpath=[a-folder]
logpath=[a-folder]
master=true
...
...
</code></pre>

<p>On your slave db server, you should write mongo config file like this<br/>
port=<a href="27018">a-port-different-from-master-db</a><br/>
dbpath=[some-place-to-store-db]<br/>
logpath=[some-place-to-store-log]<br/>
slave=true<br/>
slavedelay=7200// set as seconds<br/>
source=[master-db-ip-address]:[master-db-port]</p>

<p>After start both server, your mongodb will sync from you master server to your slave server every 2 hours.</p>

<p>Some tricks about mongod ⌘</p>

<p>Usually start with --dbpath parameter, or use --config(-f as abbr) to start with a config file.</p>

<p>--fork parameter can let mongod server runs on the background.</p>

<p>A single example of this is:<br/>
<code>mongod -f /etc/mongod.conf --fork</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode #169 Majority Element]]></title>
    <link href="http://blog.crayygy.com/14698658453148.html"/>
    <updated>2016-07-30T16:04:05+08:00</updated>
    <id>http://blog.crayygy.com/14698658453148.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
</blockquote>

<span id="more"></span><!-- more -->

<blockquote>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>

<p>Build a hash for the result, if a num is not in the hash, then make the hash[num] counts 1, else make the hash[num]+1.</p>

<p>To get the majority element of the array, just get the key with the max value in this hash.</p>

<pre><code class="language-ruby"># @param {Integer[]} nums
# @return {Integer}
def majority_element(nums)
  hash = Hash.new
  
  nums.each do |num| 
    if hash.has_key? num
      hash[num] += 1
    else
      hash[num] = 1
    end
  end
  result = hash.key(hash.values.max)
  return result
end
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode #338 Counting Bits]]></title>
    <link href="http://blog.crayygy.com/14697688870593.html"/>
    <updated>2016-07-29T13:08:07+08:00</updated>
    <id>http://blog.crayygy.com/14697688870593.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&#39;s in their binary representation and return them as an array.</p>
</blockquote>

<span id="more"></span><!-- more -->

<blockquote>
<p>Example:<br/>
For num = 5 you should return [0,1,1,2,1,2].</p>

<p>Follow up:<br/>
It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br/>
Space complexity should be O(n).<br/>
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p>
</blockquote>

<p>首先，在规定的时间复杂度下，不可能进行每一步都计算，因此考虑到 2<sup>n-1</sup> 与 2<sup>n</sup> 时的关联，利用前 2<sup>n-1</sup> 次方去推导后面2<sup>n</sup> 位。</p>

<p>考虑前16位: </p>

<pre><code>[0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
</code></pre>

<p>从二进制表示法开始入手， 如下:</p>

<table>
<thead>
<tr>
<th style="text-align: center">十进制</th>
<th style="text-align: center">二进制</th>
<th style="text-align: center">十进制</th>
<th style="text-align: center">二进制</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">0</td>
<td style="text-align: center">0</td>
<td style="text-align: center">8</td>
<td style="text-align: center">1000</td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">01</td>
<td style="text-align: center">9</td>
<td style="text-align: center">1001</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">10</td>
<td style="text-align: center">10</td>
<td style="text-align: center">1010</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">11</td>
<td style="text-align: center">11</td>
<td style="text-align: center">1011</td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: center">100</td>
<td style="text-align: center">12</td>
<td style="text-align: center">1100</td>
</tr>
<tr>
<td style="text-align: center">5</td>
<td style="text-align: center">101</td>
<td style="text-align: center">13</td>
<td style="text-align: center">1101</td>
</tr>
<tr>
<td style="text-align: center">6</td>
<td style="text-align: center">110</td>
<td style="text-align: center">14</td>
<td style="text-align: center">1110</td>
</tr>
<tr>
<td style="text-align: center">7</td>
<td style="text-align: center">111</td>
<td style="text-align: center">15</td>
<td style="text-align: center">1111</td>
</tr>
</tbody>
</table>

<p>对于任意 x， 我们可以把 x 拆成一个最大的 2<sup>n-1</sup> + 一个数(n表示当前二进制的位数)，比如:</p>

<p>\[5 = 2^2 + 2^0 + 0\\\<br/>
6 = 2^2 + 2^1 + 0\\\<br/>
14 = 2^3 + 6 = 2^3 + 2^2 + 2^1 + 0\]</p>

<p>因此在计算 x 的二进制中 1 的个数的时候，如计算 <code>5(= 101)</code>，可以通过计算 <code>1</code> 中 1 的个数，然后加上二进制最高位的1，这样就可以不需要计算每一个的二进制，直接通过前 <code>2^n-1</code>来计算。</p>

<p>因此核心算法如下:</p>

<p>\[f(x) = f(x - 2^n) + 1\]</p>

<p>最后加上的 1 即为二进制最高位的 1.<br/>
Python 代码如下：</p>

<pre><code class="language-python">class Solution(object):
    def countBits(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: List[int]
        &quot;&quot;&quot;
        array = [0]
        flag = 0 # current level
        target = num + 1
        for i in range(1, target):
            if i % pow(2, flag+1) == 0:
                flag+=1 #if a num is 2^n, then level++
            array.append(array[i-pow(2, flag)] + 1)
        
        return array
</code></pre>

<p><img src="media/14697688870593/14697691172660.jpg" alt=""/></p>

<p>算法复杂度不是很好，其中需要算平方的部分可能耗时比较多，不过相对于一个个去算已经提高了很多了。</p>

<p>应该还是有提升的空间的，需要进一步思考。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数组乱序算法]]></title>
    <link href="http://blog.crayygy.com/14639202546153.html"/>
    <updated>2016-05-22T20:30:54+08:00</updated>
    <id>http://blog.crayygy.com/14639202546153.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>给定一个已知数组<code>array[]</code>， 将 <code>array[]</code> 乱序后输出。<br/>
可以延伸为:例如，从 0～1000 中随机取数字100次，要求每次的结果不能相同。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>这道题的想法来自于遇到的一个小问题，需要将一组包含20个字符串的数组乱序输出。</p>

<h4 id="toc_0">0x00</h4>

<p>第一想法是，简单的从数组中取元素，然后加入到另一个数组中，加入之前判断这个元素是否已经存在。<br/>
这个算法的问题在于，运行初期，遇到问题的几率比较小，然而在判断最后几个元素的时候，由于巨大的碰撞几率(n个元素的数组，当第 n 个元素的时候，其实只有 \( \frac{1}{n} \) 的机会得到正确的结果)，当数组长度达到一定程度时，几乎无法使用。</p>

<h4 id="toc_1">0x01</h4>

<p>结合查到的资料，得到这样的一个算法。即: </p>

<blockquote>
<p>每次从已知数组中<code>随机</code>取一个元素放入新数组，然后将最后一个元素的值赋给这个位置，将长度减1，然后再从 <code>length-1</code> 个元素中重复上述动作，即可得到一个随机数组。</p>
</blockquote>

<p>这个算法的强势在于，时间复杂度为 \(O(n)\)，并且避开了可能出现的碰撞，实现了快速乱序。<br/>
下面是这个算法的 Java 实现(为了表述方便选择了 int 型的数组)</p>

<pre><code class="language-java">class RandomArray{
    public static int[] shuffle(int[] array) {
        int length = array.length;
        int[] shuffledArray = new int[length];

        int index = 0;

        java.util.Random random = new java.util.Random();
        for (int count=length; count&gt;0; count--) {
            int randomIndex = Math.abs(random.nextInt())%(count);
            shuffledArray[index] = array[randomIndex];
            index += 1;
            array[randomIndex] = array[count-1];
        }
        return shuffledArray;
    }
}
</code></pre>

<p>可以在这个类中增加一个测试方法:</p>

<pre><code class="language-java">    public static void printArray(int[] array){
        int len = array.length;
        for (int i=0; i&lt;len; i++) {
            System.out.print(array[i] + &quot; &quot;);
        }
        System.out.println(&quot;😀&quot;);
    }


    public static void main(String[] args) {
        int array[] = {1,2,3,4,5,6,7,8,9,0,213,123,23,1,23};
        printArray(array);

        printArray(shuffle(array));

    }
</code></pre>

<p>每次运行时产生的随机数序列都是不同的，如果需要每次运行结果相同，可以修改随机数生成算法，使得每次运行时都能得到相同的随机数序列。</p>

<h4 id="toc_2">0x02</h4>

<p><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a></p>

<blockquote>
<p>The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite set—in plain terms, the algorithm shuffles the set. The algorithm effectively puts all the elements into a hat; it continually determines the next element by randomly drawing an element from the hat until no elements remain. The algorithm produces an unbiased permutation: every permutation is equally likely. The modern version of the algorithm is efficient: it takes time proportional to the number of items being shuffled and shuffles them in place.<br/>
From wikipedia</p>
</blockquote>

<p>Fisher-Yates 算法不需要新建一个数组来保存随机后的数组，而是直接在数组中进行操作，并且时间复杂度依然是 \(O(n)\)</p>

<p>Wiki 上提供的一个伪代码如下:</p>

<pre><code>-- To shuffle an array a of n elements (indices 0..n-1):
for i from 0 to n−2 do
     j ← random integer such that 0 ≤ j &lt; n-i
     exchange a[i] and a[i+j]
</code></pre>

<p>算法思想很简单，在具有 n 个元素的数组中，从 0 到 n-2 依次进行与一个随机位置的元素进行交换。<br/>
将伪代码改写成 Java 代码:</p>

<pre><code class="language-java">public static int[] fisherShuffle(int[] array) {
        int length = array.length;
        java.util.Random random = new java.util.Random();
        for (int i=0;i&lt;length-1; i++) {
            int j = Math.abs(random.nextInt())%(length-i);
            int temp = array[i];
            array[i] = array[i+j];
            array[i+j] = temp;
        }

        return array;
    }
</code></pre>

<p>运行结果如下: <br/>
<img src="media/14639202546153/14642385093605.jpg" alt=""/></p>

<h4 id="toc_3">0x03</h4>

<p>当然如果使用像 Ruby 这样的语言，已经内置好了 shuffle 算法，只需要直接调用即可。</p>

<pre><code class="language-ruby">array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print  array
puts 
print array.shuffle
puts
</code></pre>

<p><img src="media/14639202546153/14642385924669.jpg" alt=""/></p>

<p>简直黑科技...</p>

<p>让我们大喊一声: “Ruby 大法好！”</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬楼梯算法分析详解及扩展(最大步长从2升级为m)]]></title>
    <link href="http://blog.crayygy.com/14599905787744.html"/>
    <updated>2016-04-07T08:56:18+08:00</updated>
    <id>http://blog.crayygy.com/14599905787744.html</id>
    <content type="html"><![CDATA[
<p>几天前在公司面试的时候，第二轮的面试官问了我几道算法题，第一题是Nil Game，因为之前在Leetcode上刷过这题，也在《编程之美》上看到过几种解法，很轻松就给出了正确答案。第二题问的是爬楼梯问题，即一个N阶的楼梯，每次能走1～2阶，问走到N阶一共多少种走法。之前在Leetcode上也刷过<a href="https://leetcode.com/problems/climbing-stairs/">Link</a>，面试的时候临时也想了几种不同的方法去解，回来之后又思考了一番，想出了如下几种解法。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">本文目录</h2>

<ul>
<li>
<a href="#toc_0">本文目录</a>
</li>
<li>
<a href="#toc_1">递归解法</a>
</li>
<li>
<a href="#toc_2">表达式法</a>
</li>
<li>
<a href="#toc_3">动态规划的数组实现</a>
</li>
<li>
<a href="#toc_4">队列实现</a>
</li>
<li>
<a href="#toc_5">矩阵算法</a>
</li>
<li>
<a href="#toc_6">扩展: N阶楼梯，每步可走0～m步，求解算法</a>
</li>
</ul>


<h2 id="toc_1">递归解法</h2>

<p>首先最直观的方法当然是递归求解。因为每次只能走1或2阶，因此，走上第n阶的走法应该等于第n-1阶和n-2阶的和(先走到第n-2阶然后走两阶，或者先走上第n-1阶然后走一阶)。利用 \[\\f(n) = f(n-1) + f(n-2)，f(0) = 1，f(1) = 1\]直接求解。</p>

<pre><code class="language-java">public class Solution {
    public int climbStairs(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        return climbStairs(n-1) + climbStairs(n-2);
    }
}
</code></pre>

<p><img src="media/14599905787744/14602749249993.jpg" alt=""/></p>

<p>随便给了几个测试用例，都是通过的，但是递归解法实在是太消耗资源了，因此在提交答案的时候我们会看到...<br/>
<img src="media/14599905787744/14602750216512.jpg" alt=""/><br/>
啊哦，超时了。<br/>
我们不可能局限于递归解法，因此如何对这个算法进行优化，成为了现在需要思考的问题。<br/>
PS: 如果你在面试中用了这个解法，并且没有提到说要用其他算法进行优化的话...请节哀。</p>

<h2 id="toc_2">表达式法</h2>

<p>高中学二阶数列的时候学过类似的问题，即汉诺塔问题(<a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">Link</a>)，当时不会计算机，得到的解法是 \(f(n) = 2＊f(n-1)+1\)，直接求出通项公式，代入求解。</p>

<p>对于爬楼梯算法，我们只需要求解下面这个数列的通项公式:<br/>
\[f(n) =\<br/>
\begin{cases} <br/>
f(n-1)+f(n-2)  &amp; n&gt;2 \\\<br/>
1 &amp; n=0, 1<br/>
\end{cases}<br/>
\]</p>

<p>使用数学方法可以解出 \(f(n)\)的通项公式，代入求解即可，时间复杂度为\(O(1)\)，空间复杂度，呃...和其他的相比几乎没有吧。</p>

<p>但是这种方法很不好，因为把计算的过程交给了人来完成。我们使用计算机的一个理由就是为了利用计算机解决计算问题，节约人的时间，如此算法太过于本末倒置。因此我们需要一种算法，既解决了人计算的步骤，也让计算机拥有快速的运行时间复杂度。</p>

<h2 id="toc_3">动态规划的数组实现</h2>

<p>使用数组解法，我们需要创建一个大小为n+1的数组。如果说递归解法是自顶向下的话，数组实现动态规划即是自底向上。在这个算法中，和递归解法类似，只是将<code>f(n)=f(n-1)+f(n-2)</code>换成 <code>result[n] = result[n-1]+result[n-2]</code>即可。</p>

<pre><code class="language-java">public class Solution {
    public int climbStairs(int n) {
        int[] result = new int[n];
        result[0] = 1;
        if( n&gt;= 2) {
            result[1] = 2;
        }
        for(int i = 2; i &lt; n; i++){
            result[i] = result[i-1] + result[i-2];
        }
        return result[n-1];
    }
}
</code></pre>

<p><img src="media/14599905787744/14602778120512.jpg" alt=""/></p>

<p>采用数组实现的时间复杂度为\(O(n)\)，空间复杂度为\(O(n)\)。</p>

<h2 id="toc_4">队列实现</h2>

<p>注意观察公式 \[f(n)=f(n-1)+f(n-2)\] 当求解到第n项的时候，我们实际上只需要前面两项的值，在计算第n-1项的时候，事实上需要的是第n-1项和第n项，从始至终我们接触到的值都只有三个。</p>

<p>因此，考虑一种队列实现，这个队列共有三个元素，第一个元素我们可以看成是 \(f(n-2)\)，第二个元素看成是\(f(n-1)\)，第三个元素看成是\(f(n)\)。</p>

<table>
<thead>
<tr>
<th>第一项</th>
<th>第二项</th>
<th>第三项</th>
</tr>
</thead>

<tbody>
<tr>
<td>\(f(n-2)\)</td>
<td>\(f(n-1)\)</td>
<td>\(f(n)\)</td>
</tr>
</tbody>
</table>

<p>在计算到 \(f(n+1)\)时，我们只需要将\(f(n-2)\)出队列，然后将\(f(n+1)\)入队列，此时的队列既变成了 \(f(n-1)\)，\(f(n)\)和\(f(n+1)\)。计算方法和数组实现类似。</p>

<table>
<thead>
<tr>
<th>第一项</th>
<th>第二项</th>
<th>第三项</th>
</tr>
</thead>

<tbody>
<tr>
<td>\(f(n-1)\)</td>
<td>\(f(n)\)</td>
<td>\(f(n+1)\)</td>
</tr>
</tbody>
</table>

<p>通过队列，我们成功的将空间复杂度降为\(O(1)\)(因为只用了三个元素空间来实现队列)，但是时间复杂度仍旧不变。<br/>
当然这种解法也可以通过一个大小为3数组来实现，只是在数组中我们在将第0个元素移除的时候，需要自己实现前移的过程，较为繁琐。<br/>
或者我们也可以使用三个变量num1,num2,num3来实现，只是这样一来的话，三个变量需要赋值转换，增加阅读难度。</p>

<h2 id="toc_5">矩阵算法</h2>

<p>构建一个矩阵<br/>
\[\begin{align}<br/>
\begin{bmatrix}<br/>
x_{n} \\<br/>
x_{n-1}<br/>
\end {bmatrix}<br/>
&amp;= \begin{bmatrix}<br/>
x_{n-1} + x_{n-2} \\<br/>
x_{n-1}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\\<br/>
1 &amp; 0 <br/>
\end{bmatrix} * <br/>
\begin{bmatrix}<br/>
x_{n-1} \\<br/>
x_{n-2}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{2} * <br/>
\begin{bmatrix}<br/>
x_{n-2} \\<br/>
x_{n-3}<br/>
\end{bmatrix}\\<br/>
&amp; \dots \\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{n-1} * <br/>
\begin{bmatrix}<br/>
x_{1} \\<br/>
x_{0}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{n-1} * <br/>
\begin{bmatrix}<br/>
1 \\<br/>
1<br/>
\end{bmatrix}\\<br/>
\end{align}<br/>
\]</p>

<p>在计算 \(x_{n}\)的时候，我们只需要直接计算矩阵\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-1}\)即可。<br/>
这样，我们的主要问题就转换成了求矩阵的n次方，时间复杂度降到了\(O(log n)\)</p>

<h2 id="toc_6">扩展: N阶楼梯，每步可走0～m步，求解算法</h2>

<p>从每步1～2级阶梯到1～m级阶梯，需要改变的不仅仅只是步长，还有每步走完之后，对剩余台阶总数的判断。当当总剩余的台阶数n大于步长m的时候，则第一步为1～m的一个数值，循环递归求解可能的走法。如果总剩余台阶数n小于步长m的时候，则步长调整为n，递归求解。<br/>
具体代码如下: </p>

<pre><code class="language-java">public class Solution {
    @param n: 总的台阶数
    @param m: 每次可以走的最大的阶数
    @return: 一共有多少种可能的走法
    public int climbStairs(int n, int m) {
        int stepsCount = 0;
        // 台阶数为0的时候表示已经走完
        if (n == 0) {
            return 1;
        }
        // 当总剩余的台阶数n大于步长m的时候，则 
        // 第一步为 1～m的一个数值，循环递归求解可能的走法
        if (n &gt;= m) {
            for (int i = 1; i &lt;= m; i++) {
                stepsCount += climbStairs(n-i, m);
            }
        }else { 
        // 如果总剩余台阶数n小于步长m的时候，则 步长为n，递归求解。
            stepsCount += climbStairs(n, n);
        }
        return stepsCount;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从二叉查找树到红黑树]]></title>
    <link href="http://blog.crayygy.com/14584879845645.html"/>
    <updated>2016-03-20T23:33:04+08:00</updated>
    <id>http://blog.crayygy.com/14584879845645.html</id>
    <content type="html"><![CDATA[
<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。但是，在最优情况下和最坏情况下，二叉查找树的性能差异非常的大，因此我们需要一种更优化的方式实现二叉树，红黑树闪亮登场。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">本文目录</h2>

<ul>
<li>
<a href="#toc_0">本文目录</a>
</li>
<li>
<a href="#toc_1">一、二叉查找树（BST）Wiki</a>
</li>
<li>
<a href="#toc_2">二、2-3查找树 Wiki</a>
<ul>
<li>
<a href="#toc_3">2-3查找树的性质</a>
</li>
<li>
<a href="#toc_4">2-3查找树中的查找</a>
</li>
<li>
<a href="#toc_5">2-3查找树中的插入</a>
<ul>
<li>
<a href="#toc_6">1. 向2-结点插入新键</a>
</li>
<li>
<a href="#toc_7">2. 向一棵只含有3-结点的树中插入新键</a>
</li>
<li>
<a href="#toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_10">5. 分解根结点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">小结</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">三、红黑树 Wiki</a>
<ul>
<li>
<a href="#toc_13">红黑树的性质</a>
</li>
<li>
<a href="#toc_14">红黑树中的变换</a>
<ul>
<li>
<a href="#toc_15">1. 旋转</a>
</li>
<li>
<a href="#toc_16">2. 颜色变化</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">红黑树中的插入</a>
<ul>
<li>
<a href="#toc_18">向单个的2-结点插入新键</a>
</li>
<li>
<a href="#toc_19">向一棵双键树(即一个3-结点)中插入新键</a>
</li>
<li>
<a href="#toc_20">插入算法的实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">红黑树中的查找</a>
</li>
<li>
<a href="#toc_22">红黑树中的删除</a>
</li>
<li>
<a href="#toc_23">红黑树评价</a>
</li>
</ul>
</li>
<li>
<a href="#toc_24">总结</a>
</li>
</ul>


<h2 id="toc_1">一、二叉查找树（BST）<a href="https://en.wikipedia.org/wiki/Binary_search_tree">Wiki</a></h2>

<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。二叉查找树的基本规则是：</p>

<ol>
<li>非空情况下，左结点及其子结点均小于父结点，右结点及其子结点均大于父结点</li>
<li>任意一个结点的左子结点和右子结点均是二叉查找树</li>
<li>没有两个值相等的结点</li>
</ol>

<p>二叉查找树B中查找值x的查找逻辑为：</p>

<ol>
<li>若B是空树，则搜索失败，否则：</li>
<li>若x等于根结点的值，则返回根结点；</li>
<li>若x小于根结点的值，则在左子树中搜索</li>
<li>否则，在右子树中搜索。</li>
</ol>

<p>这是个递归调用的过程(循环也可以实现)</p>

<p>二叉查找树的实现非常的简洁，但是，在最坏情况下，BST的查询时间复杂度为O(n)，即从父结点开始，所有结点均只有左子结点或者右子结点(如图1)，因此，对二叉查找树进行适当的补充修改，让它能够自动平衡树的高度，就可以实现最坏情况下也有O(log n)的时间复杂度。</p>

<p><img src="media/14584879845645/14585680661674.jpg" alt=""/></p>

<h2 id="toc_2">二、2-3查找树 <a href="https://en.wikipedia.org/wiki/2%E2%80%933_tree">Wiki</a></h2>

<h3 id="toc_3">2-3查找树的性质</h3>

<p>2-3查找树的特点是，一个结点可能具有两个子链接，也有可能具有三个子链接，取决于这个结点是2-结点还是3-结点。如图2所示。<br/>
<img src="media/14584879845645/14585758076941.jpg" alt=""/></p>

<p>可以看到，这里面所有的空链接到根结点的距离相等。在2-结点中，左结点均小于父结点，右结点均大于父结点，在3-结点中，左边值小于右边值，左结点小于左边值，右结点大于右边值，中间结点处于两值中间。</p>

<h3 id="toc_4">2-3查找树中的查找</h3>

<p>在2-3查找树中的查找与普通的二叉查找树类似，在树T中查找值x，首先x与根结点的值比较，若等于则直接返回，若小于则在左结点中查找，若大于则在右结点中查找，如果是个3-结点，则比较与左右两个值的大小，小于左值，则左子树，大于右值则右子树，大于左值小于右值则在中间结点中寻找。</p>

<h3 id="toc_5">2-3查找树中的插入</h3>

<p>在2-3查找树中的插入分成几种不同的情况：</p>

<h4 id="toc_6">1. 向2-结点插入新键</h4>

<p>如果插入的结点是一个2-结点，那么将这个结点升级成为3-结点即可(如图3)。<br/>
<img src="media/14584879845645/14587468453810.jpg" alt=""/></p>

<h4 id="toc_7">2. 向一棵只含有3-结点的树中插入新键</h4>

<p><img src="media/14584879845645/14587488829621.jpg" alt=""/></p>

<h4 id="toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</h4>

<p>这里的重点在于，插入了结点Z，之后，SX结点从3-结点变为4-结点，然后分裂成两个2-结点，将中间值X上浮到R，R所在2-结点编程3-结点，最后形成图5中的模式。<br/>
<img src="media/14584879845645/14587489097083.jpg" alt=""/></p>

<h4 id="toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</h4>

<p>向父结点为3-结点的3-结点中插入新键与上一个类似，但是需要经过多次的结点升级-&gt;裂变，因此最后构成的2-3查找树，依然是上图中的形式。</p>

<h4 id="toc_10">5. 分解根结点</h4>

<p>当根结点是一个4-结点的时候，根结点分裂成为三个2-结点，并且树的高度增加1。如图6所示。<br/>
<img src="media/14584879845645/14587498914851.jpg" alt=""/></p>

<h3 id="toc_11">小结</h3>

<p>在2-3查找树的插入操作中，最重要的是向2-和3-结点中插入结点，在结点升级之后进行的分裂操作，以及向上浮动的操作。几乎所有的插入结点都可以认为是这些操作的组合。<br/>
另外，这些变换均属于局部变换，不影响整棵树的全局有序性和平衡性。任意一个空链接到根结点的深度都是一定的。</p>

<h2 id="toc_12">三、红黑树 <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Wiki</a></h2>

<p>2-3查找树已经基本上实现了比较友好的查询时间复杂度和插入时间复杂度，重点在于如何在代码层面上实现2-3查找树。<br/>
红黑树就是一种非常简洁的实现方式。</p>

<h3 id="toc_13">红黑树的性质</h3>

<p>红黑树的链接分成两种，红链接和黑链接，红链接对应着3-的子结点，黑链接对应着2-的子结点。如图7所示。<br/>
<img src="media/14584879845645/14591302817466.jpg" alt=""/></p>

<p>3-结点 <em>AB</em>，在红黑树中的画法为右上图所示，对于红黑树而言，黑链接的深度为1，红链接的深度为0，因此可以将红链接拉平，即右下图的画法。可以看到，红黑树的红链接就是将2-3查找树中的3-结点的两个相邻结点之间用红链接来连接，在其他性质上几乎完全相同，因此，实现红黑树的算法与2-3查找树类似，如插入结点时需要用到的旋转操作等。</p>

<p>后面的实现均使用Java语言。</p>

<p>需要注意的特征有:</p>

<ol>
<li>红链接均为左链接</li>
<li>没有任何一个结点同时和两个红链接相连</li>
<li>红黑树是黑链接完美平衡的，即，任意空链接到根结点的路径上的黑链接数量相同。</li>
</ol>

<p>size()方法代码如下:</p>

<pre><code class="language-java">    public int size(){
        return size(root);
    }

    private int size(Node x) {
        if (x==null) {
            return 0;
        }
        return x.N;
    }
</code></pre>

<h3 id="toc_14">红黑树中的变换</h3>

<h4 id="toc_15">1. 旋转</h4>

<p>旋转有几种可能性，一是某结点的右链接(即右结点)为红色，我们需要将它旋转到左侧，二是将一个结点向右旋转。即，我们需要完成两个方法 rotateLeft()和rotateRight(),两个方法本身没有什么关联性，左旋转的代码和右旋转的代码只需要改变其中的right 和left即可。<br/>
代码如下:</p>

<pre><code class="language-java">    // 左旋转
    Node rotateLeft(Node h){
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
    // 右旋转
    Node rotateRight (Node h){
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
</code></pre>

<h4 id="toc_16">2. 颜色变化</h4>

<p>当一个结点同时连接两个红链接的时候，我们使用flipColors()方法来转换颜色。除了将子结点的颜色由红变黑外，还需要将父结点的颜色由黑变红。</p>

<pre><code class="language-java">    void flipColor(Node h){
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
</code></pre>

<p>另外，我们需要保证，根结点永远是黑色结点，因此在根结点为红色的时候需要进行上浮，并且树的高度增加一。</p>

<h3 id="toc_17">红黑树中的插入</h3>

<p>我们使用RED 和 BLACK 两个bool变量来标志结点的颜色，以此为链接的颜色。使用私有方法isRed()来测试一个结点和父结点之间的颜色。可以获得以下代码(在<code>RedBlackBST</code>类中):</p>

<pre><code class="language-java">    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node {
        Key key;
        Value val;
        Node left, right;
        int N;
        boolean color;

        Node(Key key, Value val, int N, boolean color){
            this.key = key;
            this.val = val;
            this.N = N;
            this.color = color;
        } 
    }

    private boolean isRed(Node x){
        if (x==null) {
            return false;
        }
        return x.color == RED;
    }
</code></pre>

<p>和2-3查找树一样，插入分为几种可能，即向2-和3-结点插入的不同。</p>

<h4 id="toc_18">向单个的2-结点插入新键</h4>

<p>一棵只有一个键的红黑树只有一个2-结点，因此，插入了一个键之后，我们需要旋转来平衡这棵树。</p>

<ol>
<li>如果新键小于旧键，则在左侧新增一个红色结点即可，新的红黑树与单个的3-结点等价。</li>
<li>如果新键大于旧键，则在右侧新增一个红色结点，然后右旋转来保证满足我们对红黑树的约束，即使用 <code>root = rotateRight(root)</code>，来将其旋转为左红链接并且修正根结点的链接，这样才算完整的完成了插入操作。</li>
<li>如果新键等于旧键，则更新旧键的值。</li>
</ol>

<p>不管是如何插入，除了更新结点外，另外两个操作最后都生成了一棵和单个的3-结点等价的红黑树，其中有两个键，左连接为红链接，树的黑链接高度为1。</p>

<h4 id="toc_19">向一棵双键树(即一个3-结点)中插入新键</h4>

<p>同样的，这种情况分为3种子情况，即新键的值与两个旧键的比较。小于两者，两者中间，大于两者。</p>

<ol>
<li>新键大于两个旧键，插入到右结点，此时这棵树是平衡的，根结点是中间大小的键，此时会产生一个具有两个红链接的父结点，此时我们将两个红结点通过颜色变换成黑色，即得到一棵由三个结点组成的高度为2的平衡树，正好能对应一棵2-3树。</li>
<li>新键小于两个旧键，新键会被建立为左结点，同样的产生了两个连续的红链接，此时只需要将上层的红链接通过右旋转即可得到第一种情况。</li>
<li>新键处于两者中间。同样的会产生两个连续的红链接，一个红色链接接一条红色右链接。将下层的红链接左旋转，即可得到第二种情况。</li>
</ol>

<p>如下图(图8)所示。<br/>
<img src="media/14584879845645/14592345345364.jpg" alt=""/></p>

<h4 id="toc_20">插入算法的实现</h4>

<pre><code class="language-java">    public void put(Key key, Value val){
        root = put(root, key, val);
        root.color = BLACK;
    }

    private Node put(Node h, Key key, Value val){
        if (h==null) {
            return new Node(key, val,1,RED);
        }
        int cmp = Key.compareTo(h.key);
        if (cmp &lt; 0) {
            h.left = put(h.left, key, val);
        }else if (cmp &gt; 0) {
            h.right = put(h.right, key, val);
        }else {
            h.val = val;
        }

        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }

        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
</code></pre>

<h3 id="toc_21">红黑树中的查找</h3>

<p>红黑树中的查找与一般的二叉查找树的查找方法完全相同。<br/>
get()方法代码如下:</p>

<pre><code class="language-java">    public Value get(Key key) {
        return get(root, key);
    }

    private Value get(Node x, Key key) {
        if(x == null) return null;
        int cmp = Key.compareTo(x.key);
        if(cmp &lt; 0) return get(x.left, key);
        else if(cmp = 0) return get(x.right, key);
        else return x.val;
    }
</code></pre>

<h3 id="toc_22">红黑树中的删除</h3>

<p>红黑树中的删除操作也是比较的复杂，直接上代码。</p>

<pre><code class="language-java">    private Node moveRedLeft(Node h) {
        // h is RED, h.left &amp; h.left.left is BLACK
        // turn h.left or one child of h.left RED
        flipColor(h);
        if (isRed(h.right.left)) {
            h.right = rotateRight(h.right);
            h.rotateLeft(h);
        }
    }

    public void deleteMin() {
        if (!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMin(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMin(Node h) {
        if (h.left == null) {
            return null;
        }
        if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) {
            h = moveRedLeft(h);
        }
        h.left = deleteMin(h.left);
        return balance(h);
    }

    private void balance(){
        if (isRed(h.right)) {
            h = rotateLeft(h);
        }
        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }
    }

    private Node moveRedRight(Node h) {
        // h is RED, h.right and h.right.left is BLACK
        // turn h.right or one child of h.right RED
        flipColor(h);
        if (!isRed(h.left.left)) {
            h= rotateRight(h);
        }
        return h;
    }

    public void deleteMax() {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMax(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMax(Node h) {
        if (isRed(h.left)) {
            h = rotateRight(h);
        }
        if (h.right == null) {
            return null;
        }
        if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
            h = moveRedRight(h);
        }
        h.right = deleteMax(h.right);
        return balance(h);
    }


    public void delete(Key key) {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = delete(root.key);
        if(isEmpty(root)) root.color = BLACK;
    }

    private void delete(Node h, Key key) {
        if(key.compareTo(h.key) &lt; 0) {
            if( !isRed(h.left) &amp;&amp; !isRed(h.left.left) ) {
                h = moveRedLeft(h);
            }
            h.left = delete(h.left, key);
        } else {
            if (isRed(h.left)) {
                h = rotateRight(h);
            }
            if (key.compareTo(h.key) == 0 &amp;&amp; h.right == null) {
                return null;
            }
            if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
                h= moveRedRight(h);
            }
            if (key.compareTo(h.key) == 0) {
                h.val = get(h.right, min(h.right).key)
                h.key = min(h.right).key;
                h.right = deleteMin(h.right);
            } else {
                h.right = delete(h.right, key);
            }
        }
        return balance(h);
    }

</code></pre>

<h3 id="toc_23">红黑树评价</h3>

<p>红黑树是一棵几乎完美平衡的树，无论键的插入顺序如何，总能得到稳定的结果，在时间复杂度上也达到了非常高的效率，而在空间复杂度上，仅在二叉查找树的每个结点上增加了一个标注颜色的布尔变量，没有增加非常多的消耗，在查找上与二叉查找树最优情况完全相同(O(log n)), 在插入操作上增加了一些旋转操作等。<br/>
并且，红黑树本质上还是一棵二叉查找树，因此二叉查找树中用到的rank(), floor(), ceiling()等方法可以不经过任何修改就可以直接使用。</p>

<h2 id="toc_24">总结</h2>

<p>首先，从简洁性上看，二叉树明显是最简单的实现方式，对于查找在最优情况下也可以实现O(log n)的复杂度，然而比较严重的问题是，如果构建这棵树时选择的根结点不是很合理，那么整棵树有可能发生严重的倾斜(最坏情况下为O(n))，如图1。因此，在二叉查找树的基础上，产生了2-3查找树。</p>

<p>2-3查找树最重要的特征是，在3-结点上插入而生成的4-结点会进行分裂，保证了2-3树的平衡性。</p>

<p>在此基础上实现了红黑树，在保持了二叉树的结构的情况下，大幅度优化了插入算法，虽然在实现上稍微复杂了一些，但能保证插入之后的树始终是一棵黑色平衡的树，因此也保证了二叉树的查询复杂度始终为O(log n)，并且不影响其它的操作。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的深度问题]]></title>
    <link href="http://blog.crayygy.com/14591320972722.html"/>
    <updated>2016-03-28T10:28:17+08:00</updated>
    <id>http://blog.crayygy.com/14591320972722.html</id>
    <content type="html"><![CDATA[
<p>昨天笔试的时候做到了一题求二叉树深度的问题，刚刚在Leetcode上刷题的时候刚好也遇到了，就顺手刷了。但是仔细思考发现，这个问题背后所反应的思想很值得我注重，因此写了这篇文章。</p>

<span id="more"></span><!-- more -->

<p>这个算法并不难，利用递归可以非常简单的求解。因此我在看到题目之后，给出的第一个解法是这样的(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int depth = 0;
        if(root.left != null &amp;&amp; root.right != null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = (l &gt; r? l : r) + 1;
        } else if (root.left == null){
            depth = maxDepth(root.right) + 1;
        } else if (root.right == null){
            depth = maxDepth(root.left) + 1;
        } else {
            depth = 0;
        }
        return depth;
    }
}

</code></pre>

<p><img src="media/14591320972722/14591324511074.jpg" alt=""/></p>

<p>解法是没有错误的，并且Leetcode上也是直接Accept了，但总是看起来让人觉得这个代码非常的丑，太杂乱了。</p>

<p>因此我又花了一点时间思考如何优化这段代码，让它看起来不至于这么的复杂。<br/>
在这个代码中，复杂的部分全部在 if-else代码块中，那么是不是可以通过其他的方式来取消掉这些判断呢？</p>

<p>答案是肯定的。因此有了下面的代码(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        
        int lDepth = maxDepth(root.left);
        int rDepth = maxDepth(root.right);
        
        return lDepth &gt; rDepth? lDepth + 1 : rDepth + 1;
    }
}
</code></pre>

<p><img src="media/14591320972722/14591326336170.jpg" alt=""/></p>

<p>可以看到，时间复杂度几乎没有变化，但是从直观上，第二段代码比之之前的版本，代码非常的简洁，并且让人一眼就能看懂意思。</p>

<p>很不幸，在笔试的时候我用的是第一段代码，并且没有考虑到优化和精简问题，不知道这个是否有影响。</p>

<p>对我而言，这两段代码给我的启发是巨大的。同样的效率的代码，如何能写的更漂亮，让别人看起来更舒服，也很重要。</p>

<p>希望以后能够多注意类似的问题，不再犯同样的错误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人博客搭建完毕]]></title>
    <link href="http://blog.crayygy.com/14582820943493.html"/>
    <updated>2016-03-18T14:21:34+08:00</updated>
    <id>http://blog.crayygy.com/14582820943493.html</id>
    <content type="html"><![CDATA[
<p>纠结了很久，终于这次把博客平台都给弄好了。<br/>
想想还是写点东西，给自己留个念想。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">服务商选择</h3>

<p>之前一直在动态博客和静态博客中纠结。但我是个不喜欢折腾的人，所以Hexo和Jekyll我都不是很喜欢，配置起来实在是有些麻烦。而Wordpress这类的动态博客又需要去自己搭建一个虚拟主机，或者去购买一个主机空间，也是比较的麻烦。索性，直接使用MWeb自带的站点功能，主题什么的我也不是很在意，就这样也挺不错。<br/>
世界上最好用的免费博客空间是什么？ 当然是Github Pages了。用MWeb生成的静态文件，直接通过git提交到Github的仓库中，便实现了静态博客的功能，评论用了多说，也挺好的。昨天刚好看到一个网友用Coding.net 和 Github Pages 加上Dnspod实现了国内外分流。于是索性也加上了Coding的Pages服务，感觉似乎也挺好的，这样blog.crayygy.com等于是拥有了两个备份，即使其中一个除了问题，我相信Dnspod也可以帮我搞定。</p>

<h3 id="toc_1">博客的内容</h3>

<p>之前也零零散散写过一些文章，要么是一些无聊的心情文字，要么就是些烂大街的教程或者评测，没什么太多意义。这次开始写博客，我想从最近开始学习的一些技术上开始入手，比如，马上就要开始学习Django和Android开发，在开发过程中必然也会遇到一些这样那样的问题，把学习过程中遇到的这样那样的问题总结一些，写一写自己的感受。</p>

<p>今天偶然间发现，SegmentFault也有写博客的功能，不过暂时还不打算去写，等到自己的文字有一定的质量的时候再转一些过去吧。</p>

<h3 id="toc_2">给自己的约定</h3>

<p>争取每周都能写一篇技术博客，一点点成长。</p>

<h4 id="toc_3">希望我能如博客名称一般，渐行渐远，哪怕走的很缓慢。</h4>

]]></content>
  </entry>
  
</feed>
