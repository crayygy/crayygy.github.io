<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[渐行渐远]]></title>
  <link href="http://blog.crayygy.com/atom.xml" rel="self"/>
  <link href="http://blog.crayygy.com/"/>
  <updated>2016-05-26T21:51:55+08:00</updated>
  <id>http://blog.crayygy.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[数组乱序算法]]></title>
    <link href="http://blog.crayygy.com/14639202546153.html"/>
    <updated>2016-05-22T20:30:54+08:00</updated>
    <id>http://blog.crayygy.com/14639202546153.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>给定一个已知数组<code>array[]</code>， 将 <code>array[]</code> 乱序后输出。<br/>
可以延伸为:例如，从 0～1000 中随机取数字100次，要求每次的结果不能相同。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>这道题的想法来自于遇到的一个小问题，需要将一组包含20个字符串的数组乱序输出。</p>

<h4 id="toc_0">0x00</h4>

<p>第一想法是，简单的从数组中取元素，然后加入到另一个数组中，加入之前判断这个元素是否已经存在。<br/>
这个算法的问题在于，运行初期，遇到问题的几率比较小，然而在判断最后几个元素的时候，由于巨大的碰撞几率(n个元素的数组，当第 n 个元素的时候，其实只有 \( \frac{1}{n} \) 的机会得到正确的结果)，当数组长度达到一定程度时，几乎无法使用。</p>

<h4 id="toc_1">0x01</h4>

<p>结合查到的资料，得到这样的一个算法。即: </p>

<blockquote>
<p>每次从已知数组中<code>随机</code>取一个元素放入新数组，然后将最后一个元素的值赋给这个位置，将长度减1，然后再从 <code>length-1</code> 个元素中重复上述动作，即可得到一个随机数组。</p>
</blockquote>

<p>这个算法的强势在于，时间复杂度为 \(O(n)\)，并且避开了可能出现的碰撞，实现了快速乱序。<br/>
下面是这个算法的 Java 实现(为了表述方便选择了 int 型的数组)</p>

<pre><code class="language-java">class RandomArray{
    public static int[] shuffle(int[] array) {
        int length = array.length;
        int[] shuffledArray = new int[length];

        int index = 0;

        java.util.Random random = new java.util.Random();
        for (int count=length; count&gt;0; count--) {
            int randomIndex = Math.abs(random.nextInt())%(count);
            shuffledArray[index] = array[randomIndex];
            index += 1;
            array[randomIndex] = array[count-1];
        }
        return shuffledArray;
    }
}
</code></pre>

<p>可以在这个类中增加一个测试方法:</p>

<pre><code class="language-java">    public static void printArray(int[] array){
        int len = array.length;
        for (int i=0; i&lt;len; i++) {
            System.out.print(array[i] + &quot; &quot;);
        }
        System.out.println(&quot;😀&quot;);
    }


    public static void main(String[] args) {
        int array[] = {1,2,3,4,5,6,7,8,9,0,213,123,23,1,23};
        printArray(array);

        printArray(shuffle(array));

    }
</code></pre>

<p>每次运行时产生的随机数序列都是不同的，如果需要每次运行结果相同，可以修改随机数生成算法，使得每次运行时都能得到相同的随机数序列。</p>

<h4 id="toc_2">0x02</h4>

<p><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a></p>

<blockquote>
<p>The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite set—in plain terms, the algorithm shuffles the set. The algorithm effectively puts all the elements into a hat; it continually determines the next element by randomly drawing an element from the hat until no elements remain. The algorithm produces an unbiased permutation: every permutation is equally likely. The modern version of the algorithm is efficient: it takes time proportional to the number of items being shuffled and shuffles them in place.<br/>
From wikipedia</p>
</blockquote>

<p>Fisher-Yates 算法不需要新建一个数组来保存随机后的数组，而是直接在数组中进行操作，并且时间复杂度依然是 \(O(n)\)</p>

<p>Wiki 上提供的一个伪代码如下:</p>

<pre><code>-- To shuffle an array a of n elements (indices 0..n-1):
for i from 0 to n−2 do
     j ← random integer such that 0 ≤ j &lt; n-i
     exchange a[i] and a[i+j]
</code></pre>

<p>算法思想很简单，在具有 n 个元素的数组中，从 0 到 n-2 依次进行与一个随机位置的元素进行交换。<br/>
将伪代码改写成 Java 代码:</p>

<pre><code class="language-java">public static int[] fisherShuffle(int[] array) {
        int length = array.length;
        java.util.Random random = new java.util.Random();
        for (int i=0;i&lt;length-1; i++) {
            int j = Math.abs(random.nextInt())%(length-i);
            int temp = array[i];
            array[i] = array[i+j];
            array[i+j] = temp;
        }

        return array;
    }
</code></pre>

<p>运行结果如下: <br/>
<img src="media/14639202546153/14642385093605.jpg" alt=""/></p>

<h4 id="toc_3">0x03</h4>

<p>当然如果使用像 Ruby 这样的语言，已经内置好了 shuffle 算法，只需要直接调用即可。</p>

<pre><code class="language-ruby">array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print  array
puts 
print array.shuffle
puts
</code></pre>

<p><img src="media/14639202546153/14642385924669.jpg" alt=""/></p>

<p>简直黑科技...</p>

<p>让我们大喊一声: “Ruby 大法好！”</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode #334 Reverse String]]></title>
    <link href="http://blog.crayygy.com/14639018379416.html"/>
    <updated>2016-05-22T15:23:57+08:00</updated>
    <id>http://blog.crayygy.com/14639018379416.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Write a function that takes a string as input and returns the string reversed.<br/>
Example:<br/>
Given s = &quot;hello&quot;, return &quot;olleh&quot;.</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>At first, I tried to solve this using char array and a for loop, like this:</p>

<pre><code class="language-java">public class Solution {
    public String reverseString(String s) {
        char[] charArray = s.toCharArray();
        String result = &quot;&quot;;
        for(int i=charArray.length; i) {
            result += charArray[i];
        }
        return result;
    }
}
</code></pre>

<p>Unfortunately, this code is out of time limits. </p>

<p>Luckily, we have a built-in java method named <code>StringBuilder</code>, we can write this code in just a single line:</p>

<pre><code class="language-java">public class Solution {
    public String reverseString(String s) {
        return new StringBuilder(s).reverse().toString();
    }
}
</code></pre>

<p>Wow!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于新的生日纪录的产品的一些想法]]></title>
    <link href="http://blog.crayygy.com/14625453863908.html"/>
    <updated>2016-05-06T22:36:26+08:00</updated>
    <id>http://blog.crayygy.com/14625453863908.html</id>
    <content type="html"><![CDATA[
<p>记住很多人的生日并不是一件容易的事情，有些时候还要去挑选礼物，实在是让人头疼。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">现状</h3>

<p>目前我已知的纪录生日的App有一个生日管家，但是基本上推送的全是广告，App内部的内容80%都是广告，实在是不想打开它。</p>

<p>对于生日纪录这一块，大部分人应该都还是以自己大脑记住为主，毕竟需要去记住生日的朋友，一般关系也很不错。但是毕竟有一些工作上的或者其他的朋友，生日的时候祝福一下会让别人的心里暖暖的，所以提醒功能还是很有必要的。</p>

<p>目前的生日提醒App，应该都是以 “提醒” 为点，并没有切到用户痛点，因此我想给这样的App添加一些功能。</p>

<h3 id="toc_1">一些思考</h3>

<p>对于我这样的人来说，每年给朋友选礼物是一件非常痛苦的事情，要考虑到方方面面，适不适合这个人，实用性如何，对方会不会已经有了，诚意如何，等等各种问题。而我自己过生日的时候则很简单，自己想要什么，送给自己一个就好。</p>

<p>这两年过生日的时候跟几个朋友约定了一下，我过生日的时候她们送我一个我想要的东西，而她们过生日的时候我送她们想要的东西，虽然跟自己买了送自己没什么区别，但是，毕竟是别人送自己的生日礼物，有可挑选的空间，并且也不会太偏离方向，并且可以送自己一些可能自己不舍得买的东西，剁手剁起来！</p>

<p>于我而言，我希望纪录生日的产品，最好能提醒我这个好友希望得到什么样的礼物，这种方式很多，比如每个人维护一份自己想要的礼物的清单，可以给好友部分显示的，或者也可以根据用户画像去自动推荐礼物，等等。</p>

<h3 id="toc_2">总结</h3>

<p>对于一个生日纪录的产品，我希望有这样的一些功能。</p>

<ol>
<li><p>记录好友生日 =&gt; 这是基础需求，否则便谈不上什么纪录</p>

<blockquote>
<p>附带的一些功能有: <br/>
1. 出生天数计算<br/>
2. 生日信息(年月日，星座等信息)<br/>
3. 生日趣数(6666天，7777天等) =&gt; 想法来自于 生日管家<br/>
4. 历史上的今天(名人生日，大事件等) =&gt; 想法来自于 Days Matter</p>
</blockquote></li>
<li><p>生日提醒 =&gt; 基础需求</p>

<blockquote>
<p>可以有的一些:<br/>
1. 提前 N 天提醒，可以是通知，也可以是邮件等<br/>
2. 每个月初提醒查看本月生日情况。<br/>
3. 提醒纪录。<br/>
4. 和日历应用关联，添加日历提醒等。<br/>
5. 申请通讯录权限，根据手机号和微信做自动匹配，可以设置自己为不可被查询。</p>
</blockquote></li>
<li><p>登录及分享等 =&gt; 基础需求</p>

<blockquote>
<p>鉴于国内环境，可以考虑手机号注册、微信登录(或者再加一个Twitter or Github)<br/>
分享的话，可以分享到各个社交网络，但是分享的内容值得仔细考虑，以App内容为主，还是以用户产出为主。</p>
</blockquote></li>
<li><p>礼物清单 =&gt; 核心功能(痛点)</p>

<blockquote>
<p>每个用户维护一个自己想要的礼物清单，这个清单应该满足:<br/>
1. 维护列表，增删改查等<br/>
2. 认领礼物，完成好友心愿，达成成就等<br/>
3. 礼物列表分类， 公开列表，私有列表，礼物针对指定用户(组)开放<br/>
4. 清单维护提醒，避免出现空清单<br/>
5. 分享清单到社交网络，有心的好友可以来认领(公开视角)</p>
</blockquote></li>
<li><p>好友分组，不同分组不同权限 =&gt; 附加需求</p>

<blockquote>
<p>这应该是必须的，对于不同分组的好友采用不同的逻辑和权限，比如<br/>
1. 对亲密好友，比如男女朋友，闺蜜之类，礼物清单可以更开放更有趣味...(污<br/>
2. 对于不熟悉的朋友，推荐礼物更加的正式一些。<br/>
3. 对于不同分组的好友的查看信息的权限，对年份的保密等。</p>
</blockquote></li>
</ol>

<p>大概就是这样的一些思路，或许我会在未来的一段时间学会 设计 + Web Dev + iOS Dev + Android Dev + 各种技能。然后专心维护这样的一个小产品，哪怕只是给朋友们用这玩玩呢～</p>

<p>以上です。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于实习]]></title>
    <link href="http://blog.crayygy.com/14613969299475.html"/>
    <updated>2016-04-23T15:35:29+08:00</updated>
    <id>http://blog.crayygy.com/14613969299475.html</id>
    <content type="html"><![CDATA[
<p>这周总算是开始了实习的生活，虽然这个学期还是每个星期三天的工作，两天的课程。周末也还是各种事情要做。<br/>
关于实习，我觉得有些话还是想说说的。</p>

<span id="more"></span><!-- more -->

<p>第一天上班的时候其实挺不愉快的，到了公司之后没人理，联系我的那个人半天找不到，最后来了一个人，告知我去办门卡之后也就消失了，办完卡发现自己要一个人坐在一个类似于公共会议室的地方(因为组里的位置不够了)，不知道自己到底是哪个组的，不知道自己具体要做的事情，也不知道自己第一天应该做哪些事情，领哪些东西，什么都不知道，心里很慌，但是面上还是很稳重，坐在自己的位置，默默的把iMac里的没用的东西删掉，然后开始配开发环境。</p>

<p>但是， 午饭的时候发现，其实同事们都很nice，没什么太多的顾虑的感觉，我知道自己的那些想法只是因为我还是第一天到，跟大家不熟悉而已，渐渐的应该会好很多。下午的时候开始熟悉自己的任务之类的，然后又花了两天时间看文档。</p>

<p>我不知道有多少人像我这样运气不错的。 到公司的时候发现自己要做的东西刚好是自己一直很想做的东西，但是现在已经有人开头了，并且是公司在支持(虽然以后我也没办法拿来用，但是毕竟做出来一个之后自己再做自己的会轻松很多)。用的技术也是自己一直很想学，但是没有一个实际的项目来入手的。整个人的心情一下子轻松了很多，看文档的时候也觉得很有意思。</p>

<p>我不知道现在的实习状态会持续多久，但是我觉得我应该会做的很开心，Nice的同事们，喜欢的技术，热衷的项目，调整一下自己的心态，下周开始就要进入项目代码中fix bugs了，熟悉了之后会好的～</p>

<p>实习的时候闲来无事想得最多的事情居然是研究生，我想我还是更愿意在学校再多待几年的吧hhhhhh</p>

<p>加油～</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬楼梯算法分析详解及扩展(最大步长从2升级为m)]]></title>
    <link href="http://blog.crayygy.com/14599905787744.html"/>
    <updated>2016-04-07T08:56:18+08:00</updated>
    <id>http://blog.crayygy.com/14599905787744.html</id>
    <content type="html"><![CDATA[
<p>几天前在公司面试的时候，第二轮的面试官问了我几道算法题，第一题是Nil Game，因为之前在Leetcode上刷过这题，也在《编程之美》上看到过几种解法，很轻松就给出了正确答案。第二题问的是爬楼梯问题，即一个N阶的楼梯，每次能走1～2阶，问走到N阶一共多少种走法。之前在Leetcode上也刷过<a href="https://leetcode.com/problems/climbing-stairs/">Link</a>，面试的时候临时也想了几种不同的方法去解，回来之后又思考了一番，想出了如下几种解法。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">本文目录</h2>

<ul>
<li>
<a href="#toc_0">本文目录</a>
</li>
<li>
<a href="#toc_1">递归解法</a>
</li>
<li>
<a href="#toc_2">表达式法</a>
</li>
<li>
<a href="#toc_3">动态规划的数组实现</a>
</li>
<li>
<a href="#toc_4">队列实现</a>
</li>
<li>
<a href="#toc_5">矩阵算法</a>
</li>
<li>
<a href="#toc_6">扩展: N阶楼梯，每步可走0～m步，求解算法</a>
</li>
</ul>


<h2 id="toc_1">递归解法</h2>

<p>首先最直观的方法当然是递归求解。因为每次只能走1或2阶，因此，走上第n阶的走法应该等于第n-1阶和n-2阶的和(先走到第n-2阶然后走两阶，或者先走上第n-1阶然后走一阶)。利用 \[\\f(n) = f(n-1) + f(n-2)，f(0) = 1，f(1) = 1\]直接求解。</p>

<pre><code class="language-java">public class Solution {
    public int climbStairs(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        return climbStairs(n-1) + climbStairs(n-2);
    }
}
</code></pre>

<p><img src="media/14599905787744/14602749249993.jpg" alt=""/></p>

<p>随便给了几个测试用例，都是通过的，但是递归解法实在是太消耗资源了，因此在提交答案的时候我们会看到...<br/>
<img src="media/14599905787744/14602750216512.jpg" alt=""/><br/>
啊哦，超时了。<br/>
我们不可能局限于递归解法，因此如何对这个算法进行优化，成为了现在需要思考的问题。<br/>
PS: 如果你在面试中用了这个解法，并且没有提到说要用其他算法进行优化的话...请节哀。</p>

<h2 id="toc_2">表达式法</h2>

<p>高中学二阶数列的时候学过类似的问题，即汉诺塔问题(<a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">Link</a>)，当时不会计算机，得到的解法是 \(f(n) = 2＊f(n-1)+1\)，直接求出通项公式，代入求解。</p>

<p>对于爬楼梯算法，我们只需要求解下面这个数列的通项公式:<br/>
\[f(n) =\<br/>
\begin{cases} <br/>
f(n-1)+f(n-2)  &amp; n&gt;2 \\\<br/>
1 &amp; n=0, 1<br/>
\end{cases}<br/>
\]</p>

<p>使用数学方法可以解出 \(f(n)\)的通项公式，代入求解即可，时间复杂度为\(O(1)\)，空间复杂度，呃...和其他的相比几乎没有吧。</p>

<p>但是这种方法很不好，因为把计算的过程交给了人来完成。我们使用计算机的一个理由就是为了利用计算机解决计算问题，节约人的时间，如此算法太过于本末倒置。因此我们需要一种算法，既解决了人计算的步骤，也让计算机拥有快速的运行时间复杂度。</p>

<h2 id="toc_3">动态规划的数组实现</h2>

<p>使用数组解法，我们需要创建一个大小为n+1的数组。如果说递归解法是自顶向下的话，数组实现动态规划即是自底向上。在这个算法中，和递归解法类似，只是将<code>f(n)=f(n-1)+f(n-2)</code>换成 <code>result[n] = result[n-1]+result[n-2]</code>即可。</p>

<pre><code class="language-java">public class Solution {
    public int climbStairs(int n) {
        int[] result = new int[n];
        result[0] = 1;
        if( n&gt;= 2) {
            result[1] = 2;
        }
        for(int i = 2; i &lt; n; i++){
            result[i] = result[i-1] + result[i-2];
        }
        return result[n-1];
    }
}
</code></pre>

<p><img src="media/14599905787744/14602778120512.jpg" alt=""/></p>

<p>采用数组实现的时间复杂度为\(O(n)\)，空间复杂度为\(O(n)\)。</p>

<h2 id="toc_4">队列实现</h2>

<p>注意观察公式 \[f(n)=f(n-1)+f(n-2)\] 当求解到第n项的时候，我们实际上只需要前面两项的值，在计算第n-1项的时候，事实上需要的是第n-1项和第n项，从始至终我们接触到的值都只有三个。</p>

<p>因此，考虑一种队列实现，这个队列共有三个元素，第一个元素我们可以看成是 \(f(n-2)\)，第二个元素看成是\(f(n-1)\)，第三个元素看成是\(f(n)\)。</p>

<table>
<thead>
<tr>
<th>第一项</th>
<th>第二项</th>
<th>第三项</th>
</tr>
</thead>

<tbody>
<tr>
<td>\(f(n-2)\)</td>
<td>\(f(n-1)\)</td>
<td>\(f(n)\)</td>
</tr>
</tbody>
</table>

<p>在计算到 \(f(n+1)\)时，我们只需要将\(f(n-2)\)出队列，然后将\(f(n+1)\)入队列，此时的队列既变成了 \(f(n-1)\)，\(f(n)\)和\(f(n+1)\)。计算方法和数组实现类似。</p>

<table>
<thead>
<tr>
<th>第一项</th>
<th>第二项</th>
<th>第三项</th>
</tr>
</thead>

<tbody>
<tr>
<td>\(f(n-1)\)</td>
<td>\(f(n)\)</td>
<td>\(f(n+1)\)</td>
</tr>
</tbody>
</table>

<p>通过队列，我们成功的将空间复杂度降为\(O(1)\)(因为只用了三个元素空间来实现队列)，但是时间复杂度仍旧不变。<br/>
当然这种解法也可以通过一个大小为3数组来实现，只是在数组中我们在将第0个元素移除的时候，需要自己实现前移的过程，较为繁琐。<br/>
或者我们也可以使用三个变量num1,num2,num3来实现，只是这样一来的话，三个变量需要赋值转换，增加阅读难度。</p>

<h2 id="toc_5">矩阵算法</h2>

<p>构建一个矩阵<br/>
\[\begin{align}<br/>
\begin{bmatrix}<br/>
x_{n} \\<br/>
x_{n-1}<br/>
\end {bmatrix}<br/>
&amp;= \begin{bmatrix}<br/>
x_{n-1} + x_{n-2} \\<br/>
x_{n-1}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\\<br/>
1 &amp; 0 <br/>
\end{bmatrix} * <br/>
\begin{bmatrix}<br/>
x_{n-1} \\<br/>
x_{n-2}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{2} * <br/>
\begin{bmatrix}<br/>
x_{n-2} \\<br/>
x_{n-3}<br/>
\end{bmatrix}\\<br/>
&amp; \dots \\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{n-1} * <br/>
\begin{bmatrix}<br/>
x_{1} \\<br/>
x_{0}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{n-1} * <br/>
\begin{bmatrix}<br/>
1 \\<br/>
1<br/>
\end{bmatrix}\\<br/>
\end{align}<br/>
\]</p>

<p>在计算 \(x_{n}\)的时候，我们只需要直接计算矩阵\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-1}\)即可。<br/>
这样，我们的主要问题就转换成了求矩阵的n次方，时间复杂度降到了\(O(log n)\)</p>

<h2 id="toc_6">扩展: N阶楼梯，每步可走0～m步，求解算法</h2>

<p>从每步1～2级阶梯到1～m级阶梯，需要改变的不仅仅只是步长，还有每步走完之后，对剩余台阶总数的判断。当当总剩余的台阶数n大于步长m的时候，则第一步为1～m的一个数值，循环递归求解可能的走法。如果总剩余台阶数n小于步长m的时候，则步长调整为n，递归求解。<br/>
具体代码如下: </p>

<pre><code class="language-java">public class Solution {
    @param n: 总的台阶数
    @param m: 每次可以走的最大的阶数
    @return: 一共有多少种可能的走法
    public int climbStairs(int n, int m) {
        int stepsCount = 0;
        // 台阶数为0的时候表示已经走完
        if (n == 0) {
            return 1;
        }
        // 当总剩余的台阶数n大于步长m的时候，则 
        // 第一步为 1～m的一个数值，循环递归求解可能的走法
        if (n &gt;= m) {
            for (int i = 1; i &lt;= m; i++) {
                stepsCount += climbStairs(n-i, m);
            }
        }else { 
        // 如果总剩余台阶数n小于步长m的时候，则 步长为n，递归求解。
            stepsCount += climbStairs(n, n);
        }
        return stepsCount;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从二叉查找树到红黑树]]></title>
    <link href="http://blog.crayygy.com/14584879845645.html"/>
    <updated>2016-03-20T23:33:04+08:00</updated>
    <id>http://blog.crayygy.com/14584879845645.html</id>
    <content type="html"><![CDATA[
<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。但是，在最优情况下和最坏情况下，二叉查找树的性能差异非常的大，因此我们需要一种更优化的方式实现二叉树，红黑树闪亮登场。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">本文目录</h2>

<ul>
<li>
<a href="#toc_0">本文目录</a>
</li>
<li>
<a href="#toc_1">一、二叉查找树（BST）Wiki</a>
</li>
<li>
<a href="#toc_2">二、2-3查找树 Wiki</a>
<ul>
<li>
<a href="#toc_3">2-3查找树的性质</a>
</li>
<li>
<a href="#toc_4">2-3查找树中的查找</a>
</li>
<li>
<a href="#toc_5">2-3查找树中的插入</a>
<ul>
<li>
<a href="#toc_6">1. 向2-结点插入新键</a>
</li>
<li>
<a href="#toc_7">2. 向一棵只含有3-结点的树中插入新键</a>
</li>
<li>
<a href="#toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_10">5. 分解根结点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">小结</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">三、红黑树 Wiki</a>
<ul>
<li>
<a href="#toc_13">红黑树的性质</a>
</li>
<li>
<a href="#toc_14">红黑树中的变换</a>
<ul>
<li>
<a href="#toc_15">1. 旋转</a>
</li>
<li>
<a href="#toc_16">2. 颜色变化</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">红黑树中的插入</a>
<ul>
<li>
<a href="#toc_18">向单个的2-结点插入新键</a>
</li>
<li>
<a href="#toc_19">向一棵双键树(即一个3-结点)中插入新键</a>
</li>
<li>
<a href="#toc_20">插入算法的实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">红黑树中的查找</a>
</li>
<li>
<a href="#toc_22">红黑树中的删除</a>
</li>
<li>
<a href="#toc_23">红黑树评价</a>
</li>
</ul>
</li>
<li>
<a href="#toc_24">总结</a>
</li>
</ul>


<h2 id="toc_1">一、二叉查找树（BST）<a href="https://en.wikipedia.org/wiki/Binary_search_tree">Wiki</a></h2>

<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。二叉查找树的基本规则是：</p>

<ol>
<li>非空情况下，左结点及其子结点均小于父结点，右结点及其子结点均大于父结点</li>
<li>任意一个结点的左子结点和右子结点均是二叉查找树</li>
<li>没有两个值相等的结点</li>
</ol>

<p>二叉查找树B中查找值x的查找逻辑为：</p>

<ol>
<li>若B是空树，则搜索失败，否则：</li>
<li>若x等于根结点的值，则返回根结点；</li>
<li>若x小于根结点的值，则在左子树中搜索</li>
<li>否则，在右子树中搜索。</li>
</ol>

<p>这是个递归调用的过程(循环也可以实现)</p>

<p>二叉查找树的实现非常的简洁，但是，在最坏情况下，BST的查询时间复杂度为O(n)，即从父结点开始，所有结点均只有左子结点或者右子结点(如图1)，因此，对二叉查找树进行适当的补充修改，让它能够自动平衡树的高度，就可以实现最坏情况下也有O(log n)的时间复杂度。</p>

<p><img src="media/14584879845645/14585680661674.jpg" alt=""/></p>

<h2 id="toc_2">二、2-3查找树 <a href="https://en.wikipedia.org/wiki/2%E2%80%933_tree">Wiki</a></h2>

<h3 id="toc_3">2-3查找树的性质</h3>

<p>2-3查找树的特点是，一个结点可能具有两个子链接，也有可能具有三个子链接，取决于这个结点是2-结点还是3-结点。如图2所示。<br/>
<img src="media/14584879845645/14585758076941.jpg" alt=""/></p>

<p>可以看到，这里面所有的空链接到根结点的距离相等。在2-结点中，左结点均小于父结点，右结点均大于父结点，在3-结点中，左边值小于右边值，左结点小于左边值，右结点大于右边值，中间结点处于两值中间。</p>

<h3 id="toc_4">2-3查找树中的查找</h3>

<p>在2-3查找树中的查找与普通的二叉查找树类似，在树T中查找值x，首先x与根结点的值比较，若等于则直接返回，若小于则在左结点中查找，若大于则在右结点中查找，如果是个3-结点，则比较与左右两个值的大小，小于左值，则左子树，大于右值则右子树，大于左值小于右值则在中间结点中寻找。</p>

<h3 id="toc_5">2-3查找树中的插入</h3>

<p>在2-3查找树中的插入分成几种不同的情况：</p>

<h4 id="toc_6">1. 向2-结点插入新键</h4>

<p>如果插入的结点是一个2-结点，那么将这个结点升级成为3-结点即可(如图3)。<br/>
<img src="media/14584879845645/14587468453810.jpg" alt=""/></p>

<h4 id="toc_7">2. 向一棵只含有3-结点的树中插入新键</h4>

<p><img src="media/14584879845645/14587488829621.jpg" alt=""/></p>

<h4 id="toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</h4>

<p>这里的重点在于，插入了结点Z，之后，SX结点从3-结点变为4-结点，然后分裂成两个2-结点，将中间值X上浮到R，R所在2-结点编程3-结点，最后形成图5中的模式。<br/>
<img src="media/14584879845645/14587489097083.jpg" alt=""/></p>

<h4 id="toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</h4>

<p>向父结点为3-结点的3-结点中插入新键与上一个类似，但是需要经过多次的结点升级-&gt;裂变，因此最后构成的2-3查找树，依然是上图中的形式。</p>

<h4 id="toc_10">5. 分解根结点</h4>

<p>当根结点是一个4-结点的时候，根结点分裂成为三个2-结点，并且树的高度增加1。如图6所示。<br/>
<img src="media/14584879845645/14587498914851.jpg" alt=""/></p>

<h3 id="toc_11">小结</h3>

<p>在2-3查找树的插入操作中，最重要的是向2-和3-结点中插入结点，在结点升级之后进行的分裂操作，以及向上浮动的操作。几乎所有的插入结点都可以认为是这些操作的组合。<br/>
另外，这些变换均属于局部变换，不影响整棵树的全局有序性和平衡性。任意一个空链接到根结点的深度都是一定的。</p>

<h2 id="toc_12">三、红黑树 <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Wiki</a></h2>

<p>2-3查找树已经基本上实现了比较友好的查询时间复杂度和插入时间复杂度，重点在于如何在代码层面上实现2-3查找树。<br/>
红黑树就是一种非常简洁的实现方式。</p>

<h3 id="toc_13">红黑树的性质</h3>

<p>红黑树的链接分成两种，红链接和黑链接，红链接对应着3-的子结点，黑链接对应着2-的子结点。如图7所示。<br/>
<img src="media/14584879845645/14591302817466.jpg" alt=""/></p>

<p>3-结点 <em>AB</em>，在红黑树中的画法为右上图所示，对于红黑树而言，黑链接的深度为1，红链接的深度为0，因此可以将红链接拉平，即右下图的画法。可以看到，红黑树的红链接就是将2-3查找树中的3-结点的两个相邻结点之间用红链接来连接，在其他性质上几乎完全相同，因此，实现红黑树的算法与2-3查找树类似，如插入结点时需要用到的旋转操作等。</p>

<p>后面的实现均使用Java语言。</p>

<p>需要注意的特征有:</p>

<ol>
<li>红链接均为左链接</li>
<li>没有任何一个结点同时和两个红链接相连</li>
<li>红黑树是黑链接完美平衡的，即，任意空链接到根结点的路径上的黑链接数量相同。</li>
</ol>

<p>size()方法代码如下:</p>

<pre><code class="language-java">    public int size(){
        return size(root);
    }

    private int size(Node x) {
        if (x==null) {
            return 0;
        }
        return x.N;
    }
</code></pre>

<h3 id="toc_14">红黑树中的变换</h3>

<h4 id="toc_15">1. 旋转</h4>

<p>旋转有几种可能性，一是某结点的右链接(即右结点)为红色，我们需要将它旋转到左侧，二是将一个结点向右旋转。即，我们需要完成两个方法 rotateLeft()和rotateRight(),两个方法本身没有什么关联性，左旋转的代码和右旋转的代码只需要改变其中的right 和left即可。<br/>
代码如下:</p>

<pre><code class="language-java">    // 左旋转
    Node rotateLeft(Node h){
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
    // 右旋转
    Node rotateRight (Node h){
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
</code></pre>

<h4 id="toc_16">2. 颜色变化</h4>

<p>当一个结点同时连接两个红链接的时候，我们使用flipColors()方法来转换颜色。除了将子结点的颜色由红变黑外，还需要将父结点的颜色由黑变红。</p>

<pre><code class="language-java">    void flipColor(Node h){
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
</code></pre>

<p>另外，我们需要保证，根结点永远是黑色结点，因此在根结点为红色的时候需要进行上浮，并且树的高度增加一。</p>

<h3 id="toc_17">红黑树中的插入</h3>

<p>我们使用RED 和 BLACK 两个bool变量来标志结点的颜色，以此为链接的颜色。使用私有方法isRed()来测试一个结点和父结点之间的颜色。可以获得以下代码(在<code>RedBlackBST</code>类中):</p>

<pre><code class="language-java">    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node {
        Key key;
        Value val;
        Node left, right;
        int N;
        boolean color;

        Node(Key key, Value val, int N, boolean color){
            this.key = key;
            this.val = val;
            this.N = N;
            this.color = color;
        } 
    }

    private boolean isRed(Node x){
        if (x==null) {
            return false;
        }
        return x.color == RED;
    }
</code></pre>

<p>和2-3查找树一样，插入分为几种可能，即向2-和3-结点插入的不同。</p>

<h4 id="toc_18">向单个的2-结点插入新键</h4>

<p>一棵只有一个键的红黑树只有一个2-结点，因此，插入了一个键之后，我们需要旋转来平衡这棵树。</p>

<ol>
<li>如果新键小于旧键，则在左侧新增一个红色结点即可，新的红黑树与单个的3-结点等价。</li>
<li>如果新键大于旧键，则在右侧新增一个红色结点，然后右旋转来保证满足我们对红黑树的约束，即使用 <code>root = rotateRight(root)</code>，来将其旋转为左红链接并且修正根结点的链接，这样才算完整的完成了插入操作。</li>
<li>如果新键等于旧键，则更新旧键的值。</li>
</ol>

<p>不管是如何插入，除了更新结点外，另外两个操作最后都生成了一棵和单个的3-结点等价的红黑树，其中有两个键，左连接为红链接，树的黑链接高度为1。</p>

<h4 id="toc_19">向一棵双键树(即一个3-结点)中插入新键</h4>

<p>同样的，这种情况分为3种子情况，即新键的值与两个旧键的比较。小于两者，两者中间，大于两者。</p>

<ol>
<li>新键大于两个旧键，插入到右结点，此时这棵树是平衡的，根结点是中间大小的键，此时会产生一个具有两个红链接的父结点，此时我们将两个红结点通过颜色变换成黑色，即得到一棵由三个结点组成的高度为2的平衡树，正好能对应一棵2-3树。</li>
<li>新键小于两个旧键，新键会被建立为左结点，同样的产生了两个连续的红链接，此时只需要将上层的红链接通过右旋转即可得到第一种情况。</li>
<li>新键处于两者中间。同样的会产生两个连续的红链接，一个红色链接接一条红色右链接。将下层的红链接左旋转，即可得到第二种情况。</li>
</ol>

<p>如下图(图8)所示。<br/>
<img src="media/14584879845645/14592345345364.jpg" alt=""/></p>

<h4 id="toc_20">插入算法的实现</h4>

<pre><code class="language-java">    public void put(Key key, Value val){
        root = put(root, key, val);
        root.color = BLACK;
    }

    private Node put(Node h, Key key, Value val){
        if (h==null) {
            return new Node(key, val,1,RED);
        }
        int cmp = Key.compareTo(h.key);
        if (cmp &lt; 0) {
            h.left = put(h.left, key, val);
        }else if (cmp &gt; 0) {
            h.right = put(h.right, key, val);
        }else {
            h.val = val;
        }

        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }

        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
</code></pre>

<h3 id="toc_21">红黑树中的查找</h3>

<p>红黑树中的查找与一般的二叉查找树的查找方法完全相同。<br/>
get()方法代码如下:</p>

<pre><code class="language-java">    public Value get(Key key) {
        return get(root, key);
    }

    private Value get(Node x, Key key) {
        if(x == null) return null;
        int cmp = Key.compareTo(x.key);
        if(cmp &lt; 0) return get(x.left, key);
        else if(cmp = 0) return get(x.right, key);
        else return x.val;
    }
</code></pre>

<h3 id="toc_22">红黑树中的删除</h3>

<p>红黑树中的删除操作也是比较的复杂，直接上代码。</p>

<pre><code class="language-java">    private Node moveRedLeft(Node h) {
        // h is RED, h.left &amp; h.left.left is BLACK
        // turn h.left or one child of h.left RED
        flipColor(h);
        if (isRed(h.right.left)) {
            h.right = rotateRight(h.right);
            h.rotateLeft(h);
        }
    }

    public void deleteMin() {
        if (!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMin(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMin(Node h) {
        if (h.left == null) {
            return null;
        }
        if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) {
            h = moveRedLeft(h);
        }
        h.left = deleteMin(h.left);
        return balance(h);
    }

    private void balance(){
        if (isRed(h.right)) {
            h = rotateLeft(h);
        }
        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }
    }

    private Node moveRedRight(Node h) {
        // h is RED, h.right and h.right.left is BLACK
        // turn h.right or one child of h.right RED
        flipColor(h);
        if (!isRed(h.left.left)) {
            h= rotateRight(h);
        }
        return h;
    }

    public void deleteMax() {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMax(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMax(Node h) {
        if (isRed(h.left)) {
            h = rotateRight(h);
        }
        if (h.right == null) {
            return null;
        }
        if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
            h = moveRedRight(h);
        }
        h.right = deleteMax(h.right);
        return balance(h);
    }


    public void delete(Key key) {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = delete(root.key);
        if(isEmpty(root)) root.color = BLACK;
    }

    private void delete(Node h, Key key) {
        if(key.compareTo(h.key) &lt; 0) {
            if( !isRed(h.left) &amp;&amp; !isRed(h.left.left) ) {
                h = moveRedLeft(h);
            }
            h.left = delete(h.left, key);
        } else {
            if (isRed(h.left)) {
                h = rotateRight(h);
            }
            if (key.compareTo(h.key) == 0 &amp;&amp; h.right == null) {
                return null;
            }
            if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
                h= moveRedRight(h);
            }
            if (key.compareTo(h.key) == 0) {
                h.val = get(h.right, min(h.right).key)
                h.key = min(h.right).key;
                h.right = deleteMin(h.right);
            } else {
                h.right = delete(h.right, key);
            }
        }
        return balance(h);
    }

</code></pre>

<h3 id="toc_23">红黑树评价</h3>

<p>红黑树是一棵几乎完美平衡的树，无论键的插入顺序如何，总能得到稳定的结果，在时间复杂度上也达到了非常高的效率，而在空间复杂度上，仅在二叉查找树的每个结点上增加了一个标注颜色的布尔变量，没有增加非常多的消耗，在查找上与二叉查找树最优情况完全相同(O(log n)), 在插入操作上增加了一些旋转操作等。<br/>
并且，红黑树本质上还是一棵二叉查找树，因此二叉查找树中用到的rank(), floor(), ceiling()等方法可以不经过任何修改就可以直接使用。</p>

<h2 id="toc_24">总结</h2>

<p>首先，从简洁性上看，二叉树明显是最简单的实现方式，对于查找在最优情况下也可以实现O(log n)的复杂度，然而比较严重的问题是，如果构建这棵树时选择的根结点不是很合理，那么整棵树有可能发生严重的倾斜(最坏情况下为O(n))，如图1。因此，在二叉查找树的基础上，产生了2-3查找树。</p>

<p>2-3查找树最重要的特征是，在3-结点上插入而生成的4-结点会进行分裂，保证了2-3树的平衡性。</p>

<p>在此基础上实现了红黑树，在保持了二叉树的结构的情况下，大幅度优化了插入算法，虽然在实现上稍微复杂了一些，但能保证插入之后的树始终是一棵黑色平衡的树，因此也保证了二叉树的查询复杂度始终为O(log n)，并且不影响其它的操作。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的深度问题]]></title>
    <link href="http://blog.crayygy.com/14591320972722.html"/>
    <updated>2016-03-28T10:28:17+08:00</updated>
    <id>http://blog.crayygy.com/14591320972722.html</id>
    <content type="html"><![CDATA[
<p>昨天笔试的时候做到了一题求二叉树深度的问题，刚刚在Leetcode上刷题的时候刚好也遇到了，就顺手刷了。但是仔细思考发现，这个问题背后所反应的思想很值得我注重，因此写了这篇文章。</p>

<span id="more"></span><!-- more -->

<p>这个算法并不难，利用递归可以非常简单的求解。因此我在看到题目之后，给出的第一个解法是这样的(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int depth = 0;
        if(root.left != null &amp;&amp; root.right != null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = (l &gt; r? l : r) + 1;
        } else if (root.left == null){
            depth = maxDepth(root.right) + 1;
        } else if (root.right == null){
            depth = maxDepth(root.left) + 1;
        } else {
            depth = 0;
        }
        return depth;
    }
}

</code></pre>

<p><img src="media/14591320972722/14591324511074.jpg" alt=""/></p>

<p>解法是没有错误的，并且Leetcode上也是直接Accept了，但总是看起来让人觉得这个代码非常的丑，太杂乱了。</p>

<p>因此我又花了一点时间思考如何优化这段代码，让它看起来不至于这么的复杂。<br/>
在这个代码中，复杂的部分全部在 if-else代码块中，那么是不是可以通过其他的方式来取消掉这些判断呢？</p>

<p>答案是肯定的。因此有了下面的代码(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        
        int lDepth = maxDepth(root.left);
        int rDepth = maxDepth(root.right);
        
        return lDepth &gt; rDepth? lDepth + 1 : rDepth + 1;
    }
}
</code></pre>

<p><img src="media/14591320972722/14591326336170.jpg" alt=""/></p>

<p>可以看到，时间复杂度几乎没有变化，但是从直观上，第二段代码比之之前的版本，代码非常的简洁，并且让人一眼就能看懂意思。</p>

<p>很不幸，在笔试的时候我用的是第一段代码，并且没有考虑到优化和精简问题，不知道这个是否有影响。</p>

<p>对我而言，这两段代码给我的启发是巨大的。同样的效率的代码，如何能写的更漂亮，让别人看起来更舒服，也很重要。</p>

<p>希望以后能够多注意类似的问题，不再犯同样的错误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人博客搭建完毕]]></title>
    <link href="http://blog.crayygy.com/14582820943493.html"/>
    <updated>2016-03-18T14:21:34+08:00</updated>
    <id>http://blog.crayygy.com/14582820943493.html</id>
    <content type="html"><![CDATA[
<p>纠结了很久，终于这次把博客平台都给弄好了。<br/>
想想还是写点东西，给自己留个念想。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">服务商选择</h3>

<p>之前一直在动态博客和静态博客中纠结。但我是个不喜欢折腾的人，所以Hexo和Jekyll我都不是很喜欢，配置起来实在是有些麻烦。而Wordpress这类的动态博客又需要去自己搭建一个虚拟主机，或者去购买一个主机空间，也是比较的麻烦。索性，直接使用MWeb自带的站点功能，主题什么的我也不是很在意，就这样也挺不错。<br/>
世界上最好用的免费博客空间是什么？ 当然是Github Pages了。用MWeb生成的静态文件，直接通过git提交到Github的仓库中，便实现了静态博客的功能，评论用了多说，也挺好的。昨天刚好看到一个网友用Coding.net 和 Github Pages 加上Dnspod实现了国内外分流。于是索性也加上了Coding的Pages服务，感觉似乎也挺好的，这样blog.crayygy.com等于是拥有了两个备份，即使其中一个除了问题，我相信Dnspod也可以帮我搞定。</p>

<h3 id="toc_1">博客的内容</h3>

<p>之前也零零散散写过一些文章，要么是一些无聊的心情文字，要么就是些烂大街的教程或者评测，没什么太多意义。这次开始写博客，我想从最近开始学习的一些技术上开始入手，比如，马上就要开始学习Django和Android开发，在开发过程中必然也会遇到一些这样那样的问题，把学习过程中遇到的这样那样的问题总结一些，写一写自己的感受。</p>

<p>今天偶然间发现，SegmentFault也有写博客的功能，不过暂时还不打算去写，等到自己的文字有一定的质量的时候再转一些过去吧。</p>

<h3 id="toc_2">给自己的约定</h3>

<p>争取每周都能写一篇技术博客，一点点成长。</p>

<h4 id="toc_3">希望我能如博客名称一般，渐行渐远，哪怕走的很缓慢。</h4>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日常工具使用安排]]></title>
    <link href="http://blog.crayygy.com/14582781733248.html"/>
    <updated>2016-03-18T13:16:13+08:00</updated>
    <id>http://blog.crayygy.com/14582781733248.html</id>
    <content type="html"><![CDATA[
<p>既然handoff这么好用，iCloud同步最近也没出什么问题的话，还是把我的随笔记录换成iOS和Mac自带的Notes吧。Notes支持文字格式，插入图片，甚至iOS上面还可以随手画，简直神器。而且iOS9.3上就可以针对单个的笔记进行加密了，如果可以对某个文件夹加密的话，我就可以把我的日记也都写在这里了，虽然DayOne真的很好用，但是真的太贵了！如果哪一天Notes支持了Markdown格式，那真是第三方的灾难。</p>

<span id="more"></span><!-- more -->

<p>换了手机之后，发现了以前用的一些软件觉得不好用完全是因为手机太卡，其实还是很好用的，比如Spark、Outlook，都是绝对的杀手级的邮箱应用，然而我直到最近才发现，真是可惜。</p>

<p>邮箱的话，Mac 和 Windows上目前使用Foxmail感觉很不错，支持自定义代理，配置一下之后就可以用gmail了，Hotmail也连接不太顺畅，所以也加上了代理。iOS上本来Spark用着挺爽畅的，没想到昨晚鬼使神差的下载了Outlook，刚刚测试了一下，速度上还是Outlook比较舒服，所以目前先观望着，看看提醒速度了，比较偏向于Outlook。</p>

<p>记笔记的话，Quiver是没什么疑问的了，最近iOS版本的Quiver内测也加入了，慢慢的应该会很好用。也支持Markdown，Latex。所以，以后程序笔记，包括代码和一些学习笔记，都纪录在Quiver里面，不过没办法在除了Mac和iOS上面看的话，还是有些蛋疼，不过问题也不大，毕竟这两个是我的主力平台。</p>

<p>MWeb还是用来写每天的Summary和博客吧，包括之前的C++ Primer学习笔记。支持七牛之后，感觉上传图片要舒服多了，而且可以直接发到静态博客里。目前准备使用MWeb编写了之后，直接发布到Github Pages和Coding Pages。</p>

<p>一些需要多个平台共用的文本之类的，包括一些简单的代码段之类的，就通过SimpleNote了，全平台舒适度相当的好，同步也很快。基本上相当于即时了。刚刚向开发者提了一下Handoff的功能，不知道会不会支持。</p>

<p>日程安排使用iCal，已经足够实用，GTD方面，暂时没有什么好的选择，也许wunderlist。Wunderlist用来安排比较长远性质的一些计划，比如学习什么技术，看什么书，以及书单，电影列表，考研计划等等，偶尔看一下，可以感受一下目标。</p>

<p>备份同步使用Dropbox，全平台都很好用。配合SS和Surge，基本上毫无压力。只是容量小了点，等回头也来邀请一波，到20G差不多就够了应该。</p>

<p>稍后阅读方面，Pocket已经沦为菜谱…感觉很难掰过来了，Instapaper 用来放一些文章，博客之类的，很好用。</p>

<p>背单词使用扇贝，每天打开，已经80多天了，没理由放弃。</p>

<p>番茄钟继续用着Pomotodo，一年的会员已经充值，非常的好用，全平台，只要有一个设备在身边就能用。</p>

]]></content>
  </entry>
  
</feed>
