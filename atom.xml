<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[渐行渐远]]></title>
  <link href="http://blog.crayygy.com/atom.xml" rel="self"/>
  <link href="http://blog.crayygy.com/"/>
  <updated>2016-03-29T16:40:52+08:00</updated>
  <id>http://blog.crayygy.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[从二叉查找树到红黑树]]></title>
    <link href="http://blog.crayygy.com/14584879845645.html"/>
    <updated>2016-03-20T23:33:04+08:00</updated>
    <id>http://blog.crayygy.com/14584879845645.html</id>
    <content type="html"><![CDATA[
<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。但是，在最优情况下和最坏情况下，二叉查找树的性能差异非常的大，因此我们需要一种更优化的方式实现二叉树，红黑树闪亮登场。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">本文目录</h2>

<ul>
<li>
<a href="#toc_0">本文目录</a>
</li>
<li>
<a href="#toc_1">一、二叉查找树（BST）Wiki</a>
</li>
<li>
<a href="#toc_2">二、2-3查找树 Wiki</a>
<ul>
<li>
<a href="#toc_3">2-3查找树的性质</a>
</li>
<li>
<a href="#toc_4">2-3查找树中的查找</a>
</li>
<li>
<a href="#toc_5">2-3查找树中的插入</a>
<ul>
<li>
<a href="#toc_6">1. 向2-结点插入新键</a>
</li>
<li>
<a href="#toc_7">2. 向一棵只含有3-结点的树中插入新键</a>
</li>
<li>
<a href="#toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_10">5. 分解根结点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">小结</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">三、红黑树 Wiki</a>
<ul>
<li>
<a href="#toc_13">红黑树的性质</a>
</li>
<li>
<a href="#toc_14">红黑树中的变换</a>
<ul>
<li>
<a href="#toc_15">1. 旋转</a>
</li>
<li>
<a href="#toc_16">2. 颜色变化</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">红黑树中的插入</a>
<ul>
<li>
<a href="#toc_18">向单个的2-结点插入新键</a>
</li>
<li>
<a href="#toc_19">向一棵双键树(即一个3-结点)中插入新键</a>
</li>
<li>
<a href="#toc_20">插入算法的实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">红黑树中的查找</a>
</li>
<li>
<a href="#toc_22">红黑树中的删除</a>
</li>
<li>
<a href="#toc_23">红黑树评价</a>
</li>
</ul>
</li>
<li>
<a href="#toc_24">总结</a>
</li>
</ul>


<h2 id="toc_1">一、二叉查找树（BST）<a href="https://en.wikipedia.org/wiki/Binary_search_tree">Wiki</a></h2>

<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。二叉查找树的基本规则是：</p>

<ol>
<li>非空情况下，左结点及其子结点均小于父结点，右结点及其子结点均大于父结点</li>
<li>任意一个结点的左子结点和右子结点均是二叉查找树</li>
<li>没有两个值相等的结点</li>
</ol>

<p>二叉查找树B中查找值x的查找逻辑为：</p>

<ol>
<li>若B是空树，则搜索失败，否则：</li>
<li>若x等于根结点的值，则返回根结点；</li>
<li>若x小于根结点的值，则在左子树中搜索</li>
<li>否则，在右子树中搜索。</li>
</ol>

<p>这是个递归调用的过程(循环也可以实现)</p>

<p>二叉查找树的实现非常的简洁，但是，在最坏情况下，BST的查询时间复杂度为O(n)，即从父结点开始，所有结点均只有左子结点或者右子结点(如图1)，因此，对二叉查找树进行适当的补充修改，让它能够自动平衡树的高度，就可以实现最坏情况下也有O(log n)的时间复杂度。</p>

<p><img src="media/14584879845645/14585680661674.jpg" alt=""/></p>

<h2 id="toc_2">二、2-3查找树 <a href="https://en.wikipedia.org/wiki/2%E2%80%933_tree">Wiki</a></h2>

<h3 id="toc_3">2-3查找树的性质</h3>

<p>2-3查找树的特点是，一个结点可能具有两个子链接，也有可能具有三个子链接，取决于这个结点是2-结点还是3-结点。如图2所示。<br/>
<img src="media/14584879845645/14585758076941.jpg" alt=""/></p>

<p>可以看到，这里面所有的空链接到根结点的距离相等。在2-结点中，左结点均小于父结点，右结点均大于父结点，在3-结点中，左边值小于右边值，左结点小于左边值，右结点大于右边值，中间结点处于两值中间。</p>

<h3 id="toc_4">2-3查找树中的查找</h3>

<p>在2-3查找树中的查找与普通的二叉查找树类似，在树T中查找值x，首先x与根结点的值比较，若等于则直接返回，若小于则在左结点中查找，若大于则在右结点中查找，如果是个3-结点，则比较与左右两个值的大小，小于左值，则左子树，大于右值则右子树，大于左值小于右值则在中间结点中寻找。</p>

<h3 id="toc_5">2-3查找树中的插入</h3>

<p>在2-3查找树中的插入分成几种不同的情况：</p>

<h4 id="toc_6">1. 向2-结点插入新键</h4>

<p>如果插入的结点是一个2-结点，那么将这个结点升级成为3-结点即可(如图3)。<br/>
<img src="media/14584879845645/14587468453810.jpg" alt=""/></p>

<h4 id="toc_7">2. 向一棵只含有3-结点的树中插入新键</h4>

<p><img src="media/14584879845645/14587488829621.jpg" alt=""/></p>

<h4 id="toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</h4>

<p>这里的重点在于，插入了结点Z，之后，SX结点从3-结点变为4-结点，然后分裂成两个2-结点，将中间值X上浮到R，R所在2-结点编程3-结点，最后形成图5中的模式。<br/>
<img src="media/14584879845645/14587489097083.jpg" alt=""/></p>

<h4 id="toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</h4>

<p>向父结点为3-结点的3-结点中插入新键与上一个类似，但是需要经过多次的结点升级-&gt;裂变，因此最后构成的2-3查找树，依然是上图中的形式。</p>

<h4 id="toc_10">5. 分解根结点</h4>

<p>当根结点是一个4-结点的时候，根结点分裂成为三个2-结点，并且树的高度增加1。如图6所示。<br/>
<img src="media/14584879845645/14587498914851.jpg" alt=""/></p>

<h3 id="toc_11">小结</h3>

<p>在2-3查找树的插入操作中，最重要的是向2-和3-结点中插入结点，在结点升级之后进行的分裂操作，以及向上浮动的操作。几乎所有的插入结点都可以认为是这些操作的组合。<br/>
另外，这些变换均属于局部变换，不影响整棵树的全局有序性和平衡性。任意一个空链接到根结点的深度都是一定的。</p>

<h2 id="toc_12">三、红黑树 <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Wiki</a></h2>

<p>2-3查找树已经基本上实现了比较友好的查询时间复杂度和插入时间复杂度，重点在于如何在代码层面上实现2-3查找树。<br/>
红黑树就是一种非常简洁的实现方式。</p>

<h3 id="toc_13">红黑树的性质</h3>

<p>红黑树的链接分成两种，红链接和黑链接，红链接对应着3-的子结点，黑链接对应着2-的子结点。如图7所示。<br/>
<img src="media/14584879845645/14591302817466.jpg" alt=""/></p>

<p>3-结点 <em>AB</em>，在红黑树中的画法为右上图所示，对于红黑树而言，黑链接的深度为1，红链接的深度为0，因此可以将红链接拉平，即右下图的画法。可以看到，红黑树的红链接就是将2-3查找树中的3-结点的两个相邻结点之间用红链接来连接，在其他性质上几乎完全相同，因此，实现红黑树的算法与2-3查找树类似，如插入结点时需要用到的旋转操作等。</p>

<p>后面的实现均使用Java语言。</p>

<p>需要注意的特征有:</p>

<ol>
<li>红链接均为左链接</li>
<li>没有任何一个结点同时和两个红链接相连</li>
<li>红黑树是黑链接完美平衡的，即，任意空链接到根结点的路径上的黑链接数量相同。</li>
</ol>

<p>size()方法代码如下:</p>

<pre><code class="language-java">    public int size(){
        return size(root);
    }

    private int size(Node x) {
        if (x==null) {
            return 0;
        }
        return x.N;
    }
</code></pre>

<h3 id="toc_14">红黑树中的变换</h3>

<h4 id="toc_15">1. 旋转</h4>

<p>旋转有几种可能性，一是某结点的右链接(即右结点)为红色，我们需要将它旋转到左侧，二是将一个结点向右旋转。即，我们需要完成两个方法 rotateLeft()和rotateRight(),两个方法本身没有什么关联性，左旋转的代码和右旋转的代码只需要改变其中的right 和left即可。<br/>
代码如下:</p>

<pre><code class="language-java">    // 左旋转
    Node rotateLeft(Node h){
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
    // 右旋转
    Node rotateRight (Node h){
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
</code></pre>

<h4 id="toc_16">2. 颜色变化</h4>

<p>当一个结点同时连接两个红链接的时候，我们使用flipColors()方法来转换颜色。除了将子结点的颜色由红变黑外，还需要将父结点的颜色由黑变红。</p>

<pre><code class="language-java">    void flipColor(Node h){
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
</code></pre>

<p>另外，我们需要保证，根结点永远是黑色结点，因此在根结点为红色的时候需要进行上浮，并且树的高度增加一。</p>

<h3 id="toc_17">红黑树中的插入</h3>

<p>我们使用RED 和 BLACK 两个bool变量来标志结点的颜色，以此为链接的颜色。使用私有方法isRed()来测试一个结点和父结点之间的颜色。可以获得以下代码(在<code>RedBlackBST</code>类中):</p>

<pre><code class="language-java">    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node {
        Key key;
        Value val;
        Node left, right;
        int N;
        boolean color;

        Node(Key key, Value val, int N, boolean color){
            this.key = key;
            this.val = val;
            this.N = N;
            this.color = color;
        } 
    }

    private boolean isRed(Node x){
        if (x==null) {
            return false;
        }
        return x.color == RED;
    }
</code></pre>

<p>和2-3查找树一样，插入分为几种可能，即向2-和3-结点插入的不同。</p>

<h4 id="toc_18">向单个的2-结点插入新键</h4>

<p>一棵只有一个键的红黑树只有一个2-结点，因此，插入了一个键之后，我们需要旋转来平衡这棵树。</p>

<ol>
<li>如果新键小于旧键，则在左侧新增一个红色结点即可，新的红黑树与单个的3-结点等价。</li>
<li>如果新键大于旧键，则在右侧新增一个红色结点，然后右旋转来保证满足我们对红黑树的约束，即使用 <code>root = rotateRight(root)</code>，来将其旋转为左红链接并且修正根结点的链接，这样才算完整的完成了插入操作。</li>
<li>如果新键等于旧键，则更新旧键的值。</li>
</ol>

<p>不管是如何插入，除了更新结点外，另外两个操作最后都生成了一棵和单个的3-结点等价的红黑树，其中有两个键，左连接为红链接，树的黑链接高度为1。</p>

<h4 id="toc_19">向一棵双键树(即一个3-结点)中插入新键</h4>

<p>同样的，这种情况分为3种子情况，即新键的值与两个旧键的比较。小于两者，两者中间，大于两者。</p>

<ol>
<li>新键大于两个旧键，插入到右结点，此时这棵树是平衡的，根结点是中间大小的键，此时会产生一个具有两个红链接的父结点，此时我们将两个红结点通过颜色变换成黑色，即得到一棵由三个结点组成的高度为2的平衡树，正好能对应一棵2-3树。</li>
<li>新键小于两个旧键，新键会被建立为左结点，同样的产生了两个连续的红链接，此时只需要将上层的红链接通过右旋转即可得到第一种情况。</li>
<li>新键处于两者中间。同样的会产生两个连续的红链接，一个红色链接接一条红色右链接。将下层的红链接左旋转，即可得到第二种情况。</li>
</ol>

<p>如下图(图8)所示。<br/>
<img src="media/14584879845645/14592345345364.jpg" alt=""/></p>

<h4 id="toc_20">插入算法的实现</h4>

<pre><code class="language-java">    public void put(Key key, Value val){
        root = put(root, key, val);
        root.color = BLACK;
    }

    private Node put(Node h, Key key, Value val){
        if (h==null) {
            return new Node(key, val,1,RED);
        }
        int cmp = Key.compareTo(h.key);
        if (cmp &lt; 0) {
            h.left = put(h.left, key, val);
        }else if (cmp &gt; 0) {
            h.right = put(h.right, key, val);
        }else {
            h.val = val;
        }

        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }

        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
</code></pre>

<h3 id="toc_21">红黑树中的查找</h3>

<p>红黑树中的查找与一般的二叉查找树的查找方法完全相同。<br/>
get()方法代码如下:</p>

<pre><code class="language-java">    public Value get(Key key) {
        return get(root, key);
    }

    private Value get(Node x, Key key) {
        if(x == null) return null;
        int cmp = Key.compareTo(x.key);
        if(cmp &lt; 0) return get(x.left, key);
        else if(cmp = 0) return get(x.right, key);
        else return x.val;
    }
</code></pre>

<h3 id="toc_22">红黑树中的删除</h3>

<p>红黑树中的删除操作也是比较的复杂，直接上代码。</p>

<pre><code class="language-java">    private Node moveRedLeft(Node h) {
        // h is RED, h.left &amp; h.left.left is BLACK
        // turn h.left or one child of h.left RED
        flipColor(h);
        if (isRed(h.right.left)) {
            h.right = rotateRight(h.right);
            h.rotateLeft(h);
        }
    }

    public void deleteMin() {
        if (!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMin(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMin(Node h) {
        if (h.left == null) {
            return null;
        }
        if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) {
            h = moveRedLeft(h);
        }
        h.left = deleteMin(h.left);
        return balance(h);
    }

    private void balance(){
        if (isRed(h.right)) {
            h = rotateLeft(h);
        }
        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }
    }

    private Node moveRedRight(Node h) {
        // h is RED, h.right and h.right.left is BLACK
        // turn h.right or one child of h.right RED
        flipColor(h);
        if (!isRed(h.left.left)) {
            h= rotateRight(h);
        }
        return h;
    }

    public void deleteMax() {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMax(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMax(Node h) {
        if (isRed(h.left)) {
            h = rotateRight(h);
        }
        if (h.right == null) {
            return null;
        }
        if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
            h = moveRedRight(h);
        }
        h.right = deleteMax(h.right);
        return balance(h);
    }


    public void delete(Key key) {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = delete(root.key);
        if(isEmpty(root)) root.color = BLACK;
    }

    private void delete(Node h, Key key) {
        if(key.compareTo(h.key) &lt; 0) {
            if( !isRed(h.left) &amp;&amp; !isRed(h.left.left) ) {
                h = moveRedLeft(h);
            }
            h.left = delete(h.left, key);
        } else {
            if (isRed(h.left)) {
                h = rotateRight(h);
            }
            if (key.compareTo(h.key) == 0 &amp;&amp; h.right == null) {
                return null;
            }
            if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
                h= moveRedRight(h);
            }
            if (key.compareTo(h.key) == 0) {
                h.val = get(h.right, min(h.right).key)
                h.key = min(h.right).key;
                h.right = deleteMin(h.right);
            } else {
                h.right = delete(h.right, key);
            }
        }
        return balance(h);
    }

</code></pre>

<h3 id="toc_23">红黑树评价</h3>

<p>红黑树是一棵几乎完美平衡的树，无论键的插入顺序如何，总能得到稳定的结果，在时间复杂度上也达到了非常高的效率，而在空间复杂度上，仅在二叉查找树的每个结点上增加了一个标注颜色的布尔变量，没有增加非常多的消耗，在查找上与二叉查找树最优情况完全相同(O(log n)), 在插入操作上增加了一些旋转操作等。<br/>
并且，红黑树本质上还是一棵二叉查找树，因此二叉查找树中用到的rank(), floor(), ceiling()等方法可以不经过任何修改就可以直接使用。</p>

<h2 id="toc_24">总结</h2>

<p>首先，从简洁性上看，二叉树明显是最简单的实现方式，对于查找在最优情况下也可以实现O(log n)的复杂度，然而比较严重的问题是，如果构建这棵树时选择的根结点不是很合理，那么整棵树有可能发生严重的倾斜(最坏情况下为O(n))，如图1。因此，在二叉查找树的基础上，产生了2-3查找树。</p>

<p>2-3查找树最重要的特征是，在3-结点上插入而生成的4-结点会进行分裂，保证了2-3树的平衡性。</p>

<p>在此基础上实现了红黑树，在保持了二叉树的结构的情况下，大幅度优化了插入算法，虽然在实现上稍微复杂了一些，但能保证插入之后的树始终是一棵黑色平衡的树，因此也保证了二叉树的查询复杂度始终为O(log n)，并且不影响其它的操作。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的深度问题]]></title>
    <link href="http://blog.crayygy.com/14591320972722.html"/>
    <updated>2016-03-28T10:28:17+08:00</updated>
    <id>http://blog.crayygy.com/14591320972722.html</id>
    <content type="html"><![CDATA[
<p>昨天笔试的时候做到了一题求二叉树深度的问题，刚刚在Leetcode上刷题的时候刚好也遇到了，就顺手刷了。但是仔细思考发现，这个问题背后所反应的思想很值得我注重，因此写了这篇文章。</p>

<span id="more"></span><!-- more -->

<p>这个算法并不难，利用递归可以非常简单的求解。因此我在看到题目之后，给出的第一个解法是这样的(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int depth = 0;
        if(root.left != null &amp;&amp; root.right != null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = (l &gt; r? l : r) + 1;
        } else if (root.left == null){
            depth = maxDepth(root.right) + 1;
        } else if (root.right == null){
            depth = maxDepth(root.left) + 1;
        } else {
            depth = 0;
        }
        return depth;
    }
}

</code></pre>

<p><img src="media/14591320972722/14591324511074.jpg" alt=""/></p>

<p>解法是没有错误的，并且Leetcode上也是直接Accept了，但总是看起来让人觉得这个代码非常的丑，太杂乱了。</p>

<p>因此我又花了一点时间思考如何优化这段代码，让它看起来不至于这么的复杂。<br/>
在这个代码中，复杂的部分全部在 if-else代码块中，那么是不是可以通过其他的方式来取消掉这些判断呢？</p>

<p>答案是肯定的。因此有了下面的代码(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        
        int lDepth = maxDepth(root.left);
        int rDepth = maxDepth(root.right);
        
        return lDepth &gt; rDepth? lDepth + 1 : rDepth + 1;
    }
}
</code></pre>

<p><img src="media/14591320972722/14591326336170.jpg" alt=""/></p>

<p>可以看到，时间复杂度几乎没有变化，但是从直观上，第二段代码比之之前的版本，代码非常的简洁，并且让人一眼就能看懂意思。</p>

<p>很不幸，在笔试的时候我用的是第一段代码，并且没有考虑到优化和精简问题，不知道这个是否有影响。</p>

<p>对我而言，这两段代码给我的启发是巨大的。同样的效率的代码，如何能写的更漂亮，让别人看起来更舒服，也很重要。</p>

<p>希望以后能够多注意类似的问题，不再犯同样的错误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人博客搭建完毕]]></title>
    <link href="http://blog.crayygy.com/14582820943493.html"/>
    <updated>2016-03-18T14:21:34+08:00</updated>
    <id>http://blog.crayygy.com/14582820943493.html</id>
    <content type="html"><![CDATA[
<p>纠结了很久，终于这次把博客平台都给弄好了。<br/>
想想还是写点东西，给自己留个念想。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">服务商选择</h3>

<p>之前一直在动态博客和静态博客中纠结。但我是个不喜欢折腾的人，所以Hexo和Jekyll我都不是很喜欢，配置起来实在是有些麻烦。而Wordpress这类的动态博客又需要去自己搭建一个虚拟主机，或者去购买一个主机空间，也是比较的麻烦。索性，直接使用MWeb自带的站点功能，主题什么的我也不是很在意，就这样也挺不错。<br/>
世界上最好用的免费博客空间是什么？ 当然是Github Pages了。用MWeb生成的静态文件，直接通过git提交到Github的仓库中，便实现了静态博客的功能，评论用了多说，也挺好的。昨天刚好看到一个网友用Coding.net 和 Github Pages 加上Dnspod实现了国内外分流。于是索性也加上了Coding的Pages服务，感觉似乎也挺好的，这样blog.crayygy.com等于是拥有了两个备份，即使其中一个除了问题，我相信Dnspod也可以帮我搞定。</p>

<h3 id="toc_1">博客的内容</h3>

<p>之前也零零散散写过一些文章，要么是一些无聊的心情文字，要么就是些烂大街的教程或者评测，没什么太多意义。这次开始写博客，我想从最近开始学习的一些技术上开始入手，比如，马上就要开始学习Django和Android开发，在开发过程中必然也会遇到一些这样那样的问题，把学习过程中遇到的这样那样的问题总结一些，写一写自己的感受。</p>

<p>今天偶然间发现，SegmentFault也有写博客的功能，不过暂时还不打算去写，等到自己的文字有一定的质量的时候再转一些过去吧。</p>

<h3 id="toc_2">给自己的约定</h3>

<p>争取每周都能写一篇技术博客，一点点成长。</p>

<h4 id="toc_3">希望我能如博客名称一般，渐行渐远，哪怕走的很缓慢。</h4>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日常工具使用安排]]></title>
    <link href="http://blog.crayygy.com/14582781733248.html"/>
    <updated>2016-03-18T13:16:13+08:00</updated>
    <id>http://blog.crayygy.com/14582781733248.html</id>
    <content type="html"><![CDATA[
<p>既然handoff这么好用，iCloud同步最近也没出什么问题的话，还是把我的随笔记录换成iOS和Mac自带的Notes吧。Notes支持文字格式，插入图片，甚至iOS上面还可以随手画，简直神器。而且iOS9.3上就可以针对单个的笔记进行加密了，如果可以对某个文件夹加密的话，我就可以把我的日记也都写在这里了，虽然DayOne真的很好用，但是真的太贵了！如果哪一天Notes支持了Markdown格式，那真是第三方的灾难。</p>

<span id="more"></span><!-- more -->

<p>换了手机之后，发现了以前用的一些软件觉得不好用完全是因为手机太卡，其实还是很好用的，比如Spark、Outlook，都是绝对的杀手级的邮箱应用，然而我直到最近才发现，真是可惜。</p>

<p>邮箱的话，Mac 和 Windows上目前使用Foxmail感觉很不错，支持自定义代理，配置一下之后就可以用gmail了，Hotmail也连接不太顺畅，所以也加上了代理。iOS上本来Spark用着挺爽畅的，没想到昨晚鬼使神差的下载了Outlook，刚刚测试了一下，速度上还是Outlook比较舒服，所以目前先观望着，看看提醒速度了，比较偏向于Outlook。</p>

<p>记笔记的话，Quiver是没什么疑问的了，最近iOS版本的Quiver内测也加入了，慢慢的应该会很好用。也支持Markdown，Latex。所以，以后程序笔记，包括代码和一些学习笔记，都纪录在Quiver里面，不过没办法在除了Mac和iOS上面看的话，还是有些蛋疼，不过问题也不大，毕竟这两个是我的主力平台。</p>

<p>MWeb还是用来写每天的Summary和博客吧，包括之前的C++ Primer学习笔记。支持七牛之后，感觉上传图片要舒服多了，而且可以直接发到静态博客里。目前准备使用MWeb编写了之后，直接发布到Github Pages和Coding Pages。</p>

<p>一些需要多个平台共用的文本之类的，包括一些简单的代码段之类的，就通过SimpleNote了，全平台舒适度相当的好，同步也很快。基本上相当于即时了。刚刚向开发者提了一下Handoff的功能，不知道会不会支持。</p>

<p>日程安排使用iCal，已经足够实用，GTD方面，暂时没有什么好的选择，也许wunderlist。Wunderlist用来安排比较长远性质的一些计划，比如学习什么技术，看什么书，以及书单，电影列表，考研计划等等，偶尔看一下，可以感受一下目标。</p>

<p>备份同步使用Dropbox，全平台都很好用。配合SS和Surge，基本上毫无压力。只是容量小了点，等回头也来邀请一波，到20G差不多就够了应该。</p>

<p>稍后阅读方面，Pocket已经沦为菜谱…感觉很难掰过来了，Instapaper 用来放一些文章，博客之类的，很好用。</p>

<p>背单词使用扇贝，每天打开，已经80多天了，没理由放弃。</p>

<p>番茄钟继续用着Pomotodo，一年的会员已经充值，非常的好用，全平台，只要有一个设备在身边就能用。</p>

]]></content>
  </entry>
  
</feed>
