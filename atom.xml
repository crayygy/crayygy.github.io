<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[渐行渐远]]></title>
  <link href="https://blog.crayygy.com/atom.xml" rel="self"/>
  <link href="https://blog.crayygy.com/"/>
  <updated>2018-05-02T20:44:58+08:00</updated>
  <id>https://blog.crayygy.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Different ways to send problem report in app with screenshots]]></title>
    <link href="https://blog.crayygy.com/15235097714605.html"/>
    <updated>2018-04-12T13:09:31+08:00</updated>
    <id>https://blog.crayygy.com/15235097714605.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">0x00 Requirements background</h2>

<p>When an application released and get used by customers, crashes and ANRs are usually the most annoying issues for developers, it&#39;s hard to get the specific context of the entire usage.</p>

<span id="more"></span><!-- more -->

<p>Usually for a wide used application, it is very important to have a feedback/help function. For a more modern way to detect where the issue is, logs and context are must. They can help developers find out how to reproduce the issue, if an issue is reproducible, in most cases it&#39;s much more easy to fix the issue or at least protect it from getting crash.</p>

<p>Currently, we have serval ways to get logs from for example, user feedback(send problem report)\Google Play console\Splunk data monitor. However, when a problem is sent with screenshots and descriptions, it&#39;s more easy to understand what an issue is and what are the bad behaviors.</p>

<h2 id="toc_1">0x01 Common solutions</h2>

<p>To get user upload screenshots, we can have serval ways to do this. We can screenshot our own application and send it when user send problem report, or ask user to upload manually. </p>

<p>For summary, I have investigated serval other applications and find there are these ways to do so:</p>

<h4 id="toc_2">1. Send feedback with auto screenshot</h4>

<h5 id="toc_3">Examples</h5>

<ul>
<li>Facebook/Messenger/Instagram</li>
</ul>

<blockquote>
<p><img src="media/15235097714605/WechatIMG34.jpeg" alt="Messenger" style="width:540px;"/></p>
</blockquote>

<h5 id="toc_4">How to</h5>

<p>When user choose to send feedback or problem, add a photo selector for user to select photos that need to send.</p>

<p>For user who want to send problem report, user are supposed to input issue description and select a photo.</p>

<h4 id="toc_5">2. Show send feedback hint when user screenshot</h4>

<h5 id="toc_6">Examples</h5>

<ul>
<li>Snapchat</li>
</ul>

<blockquote>
<p><img src="media/15235097714605/WechatIMG35.jpeg" alt="Snapchat" style="width:540px;"/></p>
</blockquote>

<h5 id="toc_7">How to</h5>

<p>To get this notification when user screenshots, we need to register file observer to detect when user takes a screenshot.</p>

<p>When this popup windows shows, we need to add some actions on it, like edit, send problem report, share..etc.</p>

<h2 id="toc_8">0x02 Comparison and conclusion</h2>

<p>The first way is more moderate and acceptable by users, when user choose to send problem reports, they can choose to add descriptions or screenshots if they have. </p>

<p>The other solution is more convenient, when user take screenshot inside an application, they might want to share, or save for future usage, or maybe they are willing to send problem report.</p>

<p>In conclusion, I think, in production mode, or released applications, the first solution is better. While for alpha users/tester/developers, the second way is more convenient to use.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A simple Android JankDetecter design and implementation]]></title>
    <link href="https://blog.crayygy.com/15206668044525.html"/>
    <updated>2018-03-10T15:26:44+08:00</updated>
    <id>https://blog.crayygy.com/15206668044525.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">0x00 Background</h2>

<p>When we developing and releasing an Android Application, we might encounter issues like Frozen Frames(FF) or Janks(according to Android Developer), to detect Janks during developing or logging, we can add a simple detector to check whether an application is going through a Jank. </p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">0x01 Detect strategy</h2>

<p>To detect whether an application is on Jank state, we can post a Handler when MainThread looper starts a new message logging printer, we could override the default Printer, when Printer is start printing a new Main looper message, at the start of the Logging, main looper will dispatch a START_TAG(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching&quot;), we can start a new LogMonitor instance, at the end of Logging, a END_TAG(&quot;&lt;&lt;&lt;&lt;&lt; Finished&quot;) will be dispatched, if all method run in the time block end during the main thread dispatch END_TAG, we can remove the LogMonitor handler.</p>

<h2 id="toc_2">Code implementation</h2>

<h3 id="toc_3">Start point</h3>

<pre><code class="language-java">    // in MyApplication.java
    if (BuildConfig.DEBUG) {
        JankDetecter.start();
    }
</code></pre>

<h3 id="toc_4">Detecter class</h3>

<pre><code class="language-java">public class JankDetecter {
    public static void start() {
        Looper.getMainLooper().setMessageLogging(new Printer() {
            private static final String START_TAG = &quot;&gt;&gt;&gt;&gt;&gt; Dispatching&quot;;
            private static final String END_TAG = &quot;&lt;&lt;&lt;&lt;&lt; Finished&quot;;
            @Override
            public void println(String x) {
                if (x.startsWith(START_TAG)) {
                    LogMonitor.getInstance().startMonitor();
                }
                if (x.startsWith(END_TAG)) {
                    LogMonitor.getInstance().removeMonitor();
                }
            }
        });
    }
}
</code></pre>

<h3 id="toc_5">LogMonitor class</h3>

<pre><code class="language-java">public class LogMonitor {
    private static LogMonitor sInstance = new LogMonitor();
    private HandlerThread mLogThread = new HandlerThread(&quot;log&quot;);
    private Handler mIoHander;
    private static final long TIME_BLOCK = 500L;

    private LogMonitor() {
        mLogThread.start();
        mIoHander = new Handler(mLogThread.getLooper());
    }
    public static LogMonitor getInstance() {
        return sInstance;
    }
    public void startMonitor() {
        mIoHander.postDelayed(mLogRunnable, TIME_BLOCK);
    }
    public void removeMonitor() {
        mIoHander.removeCallbacks(mLogRunnable);
    }
    private static Runnable mLogRunnable = new Runnable() {
        @Override
        public void run() {
            StringBuilder stringBuilder = new StringBuilder();
            StackTraceElement[] stackTraces = Looper.getMainLooper().getThread().getStackTrace();
            for (StackTraceElement s : stackTraces) {
                stringBuilder.append(s.toString() + &quot;\n&quot;);
            }
        }
    };
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android App Layout performance optimization investigation]]></title>
    <link href="https://blog.crayygy.com/15174963911041.html"/>
    <updated>2018-02-01T22:46:31+08:00</updated>
    <id>https://blog.crayygy.com/15174963911041.html</id>
    <content type="html"><![CDATA[
<p><a href="https://developer.android.com/topic/performance/vitals/render.html">Slow rendering</a> can cause <code>Frozen Frames</code> issue.<br/>
To avoid <code>Slow Rendering</code> issue. Try to analysis Android App with tools.</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">0x00 Tools used</h2>

<p>There are serval tools can be used to help us check view/layout performance.</p>

<ol>
<li><p>Hierarchy viewer</p>

<blockquote>
<ul>
<li><a href="https://developer.android.com/studio/profile/hierarchy-viewer.html">Hierarchy View</a></li>
<li><a href="http://blog.csdn.net/xyz_lmn/article/details/14222975">Some blog</a></li>
<li>Not very easy to use, loading slow.</li>
<li>Can help detect the layout hierarchy and check if too many level of views(Can use lint instead)</li>
</ul>
</blockquote></li>
<li><p>Trace view</p>

<blockquote>
<ul>
<li><a href="https://developer.android.com/studio/profile/traceview.html">Trace View</a></li>
<li>Need enable adb integration in Android Studio -&gt; Tools -&gt; Android -&gt; Enable ADB integration</li>
<li><a href="https://developer.android.com/studio/preview/features/android-profiler.html?utm_source=android-studio">Android Profiler</a></li>
<li>Using Android Profiler, choose CPU usage.</li>
<li>Recoding the actions/CPU usage when doing somvething.</li>
<li>References:

<ol>
<li><a href="https://bxbxbai.github.io/2014/10/25/use-trace-view/">正确使用Android性能分析工具——TraceView</a></li>
<li><a href="http://blog.csdn.net/u011240877/article/details/54347396">Android 性能优化：使用 TraceView 找到卡顿的元凶</a></li>
</ol></li>
</ul>
</blockquote></li>
<li><p>systrace</p>

<blockquote>
<ul>
<li><a href="https://developer.android.com/studio/command-line/systrace.html">systrace</a></li>
<li>Useful ⌘: <code>python systrace.py -a com.cisco.im --time=15 -o ~/Desktop/trace.html sched gfx view wm</code></li>
<li>Open this HTML file in Chrome(only Chrome)</li>
<li>Find alert on the right side.</li>
</ul>
</blockquote></li>
<li><p>Lint</p>

<blockquote>
<ul>
<li>First config rules in Android studio -&gt; preferences -&gt; Editor -&gt; Inspections, check all related rules</li>
<li>Goto Android studio -&gt; Analyze -&gt; Inspect code, choose res folder</li>
<li>Start inspection</li>
<li>Check out Android Studio panel</li>
</ul>
</blockquote></li>
</ol>

<h2 id="toc_1">0x01 Lint result</h2>

<h3 id="toc_2">Main issues</h3>

<ol>
<li><p>Unused XML schema declaration</p>

<blockquote>
<p>A layout with children that has no siblings, is not a scrollview or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.</p>
</blockquote></li>
<li><p>Long vector paths</p>

<blockquote>
<p>Using long vector paths is bad for performance. There are several ways to make the pathData shorter:<br/>
* Using less precision<br/>
* Removing some minor details<br/>
* Using the Android Studio vector conversion tool<br/>
* Rasterizing the image (converting to PNG)</p>
</blockquote></li>
<li><p>Node can be replaced by a TextView with compound drawables</p>

<blockquote>
<p>A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable (a single TextView, using the drawableTop, drawableLeft, drawableRight and/or drawableBottom attributes to draw one or more images adjacent to the text).</p>
</blockquote></li>
</ol>

<p><img src="media/15174963911041/15172821034634.jpg" alt="XML lint result"/></p>

<h2 id="toc_3">0x02 systrace results</h2>

<p>Checked on four main page:[HomeActivity(Including contact list, profile), ChatActivity(Including sending chat, emoticon), Call(Incoming call), Settings(List)]</p>

<h3 id="toc_4">Trace alert</h3>

<p>These alerts are found in systrace.html</p>

<ol>
<li>Scheduling delay</li>
<li>Expensive measure/layout pass    -&gt; Need more check</li>
<li>Long View#draw()</li>
<li>Inefficient View alpha usage</li>
<li>Inflation during ListView recycling  -&gt; Need more check</li>
</ol>

<h2 id="toc_5">0x03 Trace view</h2>

<p>Trace view can help check code call stack and find which piece of codes block the CPU time most.</p>

<p><img src="media/15174963911041/15172899439685.jpg" alt="TraceView CPU Overview"/></p>

<p>According to the result of trace view, the most time cost methods are from View, measure, layout, drawing..etc(excluding handler).</p>

<ol>
<li>When goto contact profile page in contact list:</li>
</ol>

<blockquote>
<p><img src="media/15174963911041/15172911758858.jpg" alt="Contact Profile"/></p>
</blockquote>

<ol>
<li>When Sign in: (Cost about 30s, debug mode, cisco.com)</li>
</ol>

<blockquote>
<p><img src="media/15174963911041/15172915369332.jpg" alt="Sign in"/></p>

<p>The main reason for time cost is the login flow(UI is not stuck)<br/>
Signed in moment:<br/>
<img src="media/15174963911041/15172920127852.jpg" alt="Signin to HomeActivity"/><br/>
The most time cost is android.view.LayoutInfalter<br/>
HomeActivity creation cost a lot of time. (Create all views, load all tabs, handle callback..etc.)</p>
</blockquote>

<h2 id="toc_6">0x04 Summary</h2>

<h3 id="toc_7">Part 1: View measure/layout/drawing</h3>

<ol>
<li>Some layout can be replaced by a simpler layout, use RelativeLayout instead of complex LinearLayout.</li>
<li>Using TextView with drawable instead of using a LinearLayout with a TextView and a ImageView.</li>
</ol>

<p><img src="media/15174963911041/15172930792094.jpg" alt="View drawing"/></p>

<h3 id="toc_8">Part 2: Reduce unused callback/handler for sign in part</h3>

<ol>
<li>When signed in, we receive too many callbacks, handle too many event, such as: invalid credentials, popup fingerprint authentication, auto upgrade check, other handlers...
&gt; For those not urgent event/handlers, we can put it back after signed in for a while, not the time when create HomeActivity</li>
<li>Too many Views/Layouts/Loading time when create HomeActivity
&gt; Reduce view hierarchy in HomeActivity, refactor View layouts</li>
</ol>

<h3 id="toc_9">Part 3: Telemetry</h3>

<p>Telemetry data can be used to monitor application runtime CPU and memory usage information.<br/>
There are some tools can help us. We can choose to use 3rd party tools or write by ourself.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android(Java) 中的单例类的实现]]></title>
    <link href="https://blog.crayygy.com/15169769464198.html"/>
    <updated>2018-01-26T22:29:06+08:00</updated>
    <id>https://blog.crayygy.com/15169769464198.html</id>
    <content type="html"><![CDATA[
<p>单例模式(Singleton) 是我们常用的一种设计模式，通常用来保证在全局情况下总是能够拿到同样的一个类实例来实现相关的工作。<br/>
  单例模式很常见，因此也有戏称：</p>

<blockquote>
<p>单例的写法茴香豆的<code>茴</code>的写法还多。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">0x00 简单的单例类</h2>

<p>单线程模式下的单例模式常见的写法比如：</p>

<pre><code class="language-java">  public class Singleton {
    private static Singleton INSTANCE; 
    private Singleton() {}
 
    public static Singleton getInstance() {
        if(null==INSTANCE) INSTANCE = new Singleton()
        return INSTANCE;
    }
  }

</code></pre>

<p>代码很简单，就是私有化构造方法，并且使用一个 public 方法来获取实例，但是仅限于单线程的时候。</p>

<h2 id="toc_1">0x01 多线程下的一种实现</h2>

<p>在多线程的时候这样的单例类如果在多个线程同时调用的时候，很可能就会导致初始化问题(两个线程同时拿到了一个 null 的实例，同时进入了新的初始化)，因此在多线程下，我们的代码中使用了这样的方式来实现单例。</p>

<pre><code class="language-java">public class Singleton {
    private static Singleton INSTANCE;
    private Singleton() { }
    public static Singleton getInstance() {
        if (null == INSTANCE) {
            synchronized (Singleton.class) {
                if (null==INSTANCE) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}

</code></pre>

<h2 id="toc_2">0x02 对比分析</h2>

<p>上面实现的这样的单例类，通过加了<code>synchronized</code>锁来保证同一时刻只有一个线程能够进入到这个临界区中，并且通过两次的 null check 来确保不会重复创建实例，这样做对吗？好不好呢？</p>

<p>在分析这段代码的问题之前，我们先看一下 Google 提倡的一种单例类的实现。</p>

<pre><code class="language-java">public class Singleton {
    private static Singleton INSTANCE;
    private Singleton() { }

     public static synchronized Singleton getInstance() {
        if (null == INSTANCE) {
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }
}

</code></pre>

<p>对比一下代码我们会发现，这两段代码的主要区别在于，一个是对创建新的实例进行了加锁，而另一个则是在每一次获取实例的时候，都加锁，这样来保证不会有异常情况。第一种写法在已经创建完实例后就不会再进行 <code>synchronized</code> 操作，这样可以节约一部分操作时间（毕竟不是经常需要加锁来创建新的实例的），第二段代码保证了每次调用都不会出问题，但是会多一些额外的消耗。</p>

<p>说到异常，我们来看一下第一段代码为什么是有问题的，这个地方非常的有趣并且很不容易发现，我们是通过 Coverity 这个工具，看到了代码中这样的实现被它给标为 High level 的 bug，才想到这里可能会有这样的问题，一开始还很奇怪为什么加了两次 null check，还会丢 warning 出来，难不成还会创建两个实例不成？</p>

<h2 id="toc_3">0x03 揭秘</h2>

<p>让我们再来看一遍这段代码：</p>

<pre><code class="language-java">    public static Singleton getInstance() {
        if (null == INSTANCE) {
            synchronized (Singleton.class) {
                if (null==INSTANCE) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
</code></pre>

<p>首先，通过一次 null check, 判断是否需要创建新的实例，如果已经有这个实例了，那么OK，直接返回，如果没有，我们先申请一下锁，拿到之后，进行第二次 null check，这是因为可能在线程等待锁的过程中，已经有另一个线程拿到了锁，并且创建好了资源，如果发现已经不是 null 了，不做任何事，安静的释放掉锁，然后返回，如果发现自己仍然是空的呢，那么就开始进行新的创建实例操作。</p>

<p>到这里是不是还没有发现任何不太对劲的地方？放心，不可能出现两个实例。</p>

<p>那么问题出现在哪里呢？</p>

<p>我们来温习一下创建一个类的实例的过程：类加载(class loader)，分配方法区，堆，常量池，构造函数，初始化函数...等等等等</p>

<p>让我们再来温习一个概念，<mark><em>原子操作</em></mark>。</p>

<p>是不是终于意识到不对的地方了，恭喜！让我们一起来看看，为什么 coverity 会报出这段代码的 warning。</p>

<p>首先，这段代码的核心在于要返回一个实例（废话），不管是已经存在的，还是新创建的，已经存在的自然不用说了，问题就出现在这个新创建的实例上。创建实例的时候我们用了这样的一句话：</p>

<pre><code class="language-java">INSTANCE = new Singleton();
</code></pre>

<p>一切的烦恼皆因此而起。</p>

<p>在我们初始化实例的时候，在某一个瞬间，<code>INSTANCE</code>已经有了引用（构造完成了），但是初始化并没有完成！假象一下有两个线程 <code>Thread A</code> 和 <code>Thread B</code>，最开始的时候，单例还没有被初始化，于是当 <code>Thread A</code> 调用 <code>Singleton.getInstance()</code> 的时候，初始化开始了。</p>

<p>而刚好在这一时刻，<code>Thread B</code> 也来调用 <code>Singleton.getInstance()</code>，问题来了，在第一次 null check 的时候，INSTANCE 是 null 吗？</p>

<p>是？不是？</p>

<p>别急着回答。由于这个时候 <code>Thread A</code> 正在紧锣密鼓的筹办 <code>Singleton</code> 类的构造和初始化，究竟进行到了哪一步了我们也不知道，是正在构造呢，还是已经构造完了刚准备初始化，还是初始化到一半了？</p>

<p>而此时的 <code>Thread B</code>，在第一次 null check 的时候内心是不安的，因为如果这个时候 <code>INSTANCE</code> 还是个 null 的，那还好，大不了我等嘛，等你释放锁了，我拿到锁了进去看一下，不是 null 的我就直接回去就是了，可万一 <code>INSTANCE</code> 不是 null 的，这个时候就头大了。</p>

<p>不是 null 啊，初始化完成了吗？如果初始化过程中要做的事情非常的多，或者很耗时（比如注册一个服务，通过网络请求去拿一个config），这个时候就不好说了，虽然 <code>Thread B</code> 拿到了一个不是 null 的 <code>INSTANCE</code>，但是谁知道用起来会不会 <code>Crash</code>，这简直就是个定时炸弹啊！</p>

<p>当然了，这样的情形我们假设的时候是遇到了，但是现实里两个线程在几乎同时（大概几百毫秒内）同时去拿一个单例，可能性虽然有，但毕竟还是比较小的。 但是！一旦出现了这样的bug，debug 的时候怎么去发现？？？ 也很难有办法重现，于是这里就成了一个埋藏至深的地雷，说不定哪天不开心了就炸了。</p>

<h2 id="toc_4">0x04 解决方案</h2>

<p>找到了问题的根源，要解决这样的 bug 就简单了。很好说，归根结底，这个问题出现是因为两个线程 <code>A</code> and <code>B</code> 在同一时刻对同一实例 <code>INSTANCE</code> 进行了读写操作。直接给你禁了呗。</p>

<p>说的好！怎么禁？简单啊，一个单词的事儿，<code>volatile</code>，搞定！</p>

<p>代码如下:</p>

<pre><code class="language-java">public class Singleton {
    private static volatile Singleton INSTANCE;

    private Singleton() { }

    public static Singleton getInstance() {
        if (null == INSTANCE) {
            synchronized (Singleton.class) {
                if (null == INSTANCE) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
</code></pre>

<p>跟最初的版本相比，只是多加了一个 <code>volatile</code> 关键字，但是就这样解决了这个看起来很麻烦的问题，是不是很开心！</p>

<blockquote>
<p>关于 <code>volatile</code> 关键字有机会再展开。</p>
</blockquote>

<h2 id="toc_5">0x05 能再简单点儿么？</h2>

<p>能！</p>

<p>让我们回到最初的起点，问一下自己，为什么要写出这么麻烦的 code？</p>

<blockquote>
<p>为了让单例类在多线程的情况下没有异常。</p>
</blockquote>

<p>那让我们以这个为目标，再重新思考一下，有没有别的方法。</p>

<p>Talk is cheap, show me the code.</p>

<pre><code class="language-java">public class Singleton {
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton() { }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
</code></pre>

<p>通过一个内部的静态类来完成实例的单例，并且保证了在多线程的时候不会有异常，为什么？提示，在内部静态类加载的时候进行的初始化。</p>

<p>其实呢，如果要求更低一点，在单例类的初始化过程没有那么复杂或者耗时的操作的时候，可以直接用最简单的实现，即直接初始化。</p>

<pre><code class="language-java">public class Singleton {
    private INSTANCE = new Singleton();
    private Singleton() { }

    public static Singleton getInstance() {
        return INSTANCE;
    }
}

</code></pre>

<h2 id="toc_6">0x06 总结</h2>

<p>小小的总结一下关于这篇文章。今天下午在公司里跟同事一起讨论单例的实现的时候，刚好看到 coverity 给我们报了这样的bug，几个人坐在那里简单讨论了一下，也没商量出个对策来，又因为时间紧迫，还要完成今天的测试，因此就搁置了。回到家闲着也是闲着，边备份 Time Machine 边想这个问题，顺带着看看其他人的博客什么的，也便有了这篇博客。</p>

<p>里面出现的一些写法我相信都是经常出现的，包括有问题的，Google 推荐的，还有最后使用内部静态类的（其实这个方法是 Effective Java）中推荐过的，当然还有比如更新的使用一个 Enum 来实现的，单例的写法是真的要比<code>茴</code>字的写法还要多的。</p>

<p>总结经验教训来看的话，</p>

<ol>
<li>Coverity 是个很不错的工具</li>
<li>多思考（没事多想想为什么）</li>
<li>多看书（强力推荐 Effective Java）</li>
<li>多动手（写篇博客很有成就感的，真的）</li>
</ol>

<p>That&#39;s all! <br/>
Thanks a lot~</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android MediaPlayer setData 0X8000000 error]]></title>
    <link href="https://blog.crayygy.com/15118733745760.html"/>
    <updated>2017-11-28T20:49:34+08:00</updated>
    <id>https://blog.crayygy.com/15118733745760.html</id>
    <content type="html"><![CDATA[
<p>This issue might be caused by ringtone permission, if using a custom ringtone or ringtone set by other apps, must ensure your app has storage permission, otherwise, you cannot setDataUri to MediaPlayer instance.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Dive into Ruby] Ruby 中的方法、类与模块]]></title>
    <link href="https://blog.crayygy.com/15080417250719.html"/>
    <updated>2017-10-15T12:28:45+08:00</updated>
    <id>https://blog.crayygy.com/15080417250719.html</id>
    <content type="html"><![CDATA[
<p>介绍完了 Ruby 的语言基础与控制流，对于 Ruby 也算有了一个比较亲密的接触了，接下来是一些比较常用的面向对象（Object Oriented）的思想与方法。 这一部分与其它的面向对象语言比较的类似，但依然有很多地方有着鲜明的 Ruby 特色。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Ruby 中的函数/方法(function/method)</h2>

<p>首先，什么是<code>函数</code>？</p>

<p>对于已经有编程基础的人来说，这是一个非常直白的问题，但是如果是要向没有接触过编程的人介绍函数呢？ 我对函数的理解是这样的。</p>

<blockquote>
<p>函数是一系列操作的集合体，有着定义的输入（<code>参数</code>），通过这个操作集合之后输出定义的结果（返回值）。</p>
</blockquote>

<p>比如说，加法是一个函数，这个函数接收两个参数：加数与被加数，进行将两个输入参数相加的操作，最后返回出加法结果。</p>

<p>要说明下，<code>函数</code>这个概念是属于面向过程的思想的，在面向对象的世界里，名字叫<code>方法</code>。</p>

<p>那么<code>方法</code>是什么，应该怎么理解呢？同样附上我的个人看法。</p>

<blockquote>
<p><code>方法</code>是一个对象自身所能够拥有的操作手段，例如，<code>Object</code> 类实现了 <code>instanse_of?</code>方法，这个方法就是所有的<code>Object</code>类的实例所能够拥有的操作，再例如，<code>Math</code>类拥有<code>Math.asin()</code>方法，这是 <code>Math</code> 这个 <code>类</code> 所拥有的操作。</p>
</blockquote>

<p>从上面的描述中也可以看到，方法是属于 <code>Object</code> 的，而根据方法所属的 <code>Object</code> 不同，将方法分成两类：<code>实例方法</code>、<code>类方法</code>。</p>

<h3 id="toc_1"><code>方法</code>的分类</h3>

<p>实例方法与类方法，顾名思义，是分别属于实例的与类的方法。</p>

<p>关于<code>实例</code>与<code>类</code>的关系，在介绍<code>类</code>的时候详细介绍。这里需要弄清楚的是：<code>实例方法</code>是通过<code>实例</code>来调用的，而<code>类方法</code>则是直接通过<code>类</code>来调用。</p>

<p>同样的，对比 Java 中的概念，<code>实例方法</code>与<code>类方法</code>基本上等同于 Java 中的 <code>非静态方法</code> 与 <code>静态方法</code>。</p>

<blockquote>
<p>在 Java 中，非静态方法通过类的对象调用，静态方法需要通过类调用。</p>
</blockquote>

<p>简单的举两个例子。</p>

<pre><code class="language-ruby">student = Student.new
student.grade = 3
student.read()
student.calculate(Math.PI)

Math.asin(Math.PI/2)
</code></pre>

<p>在这个例子中，分别出现了<code>类方法</code>与<code>实例方法</code>，<code>类变量</code>与<code>实例变量</code>。 <code>Student.new</code> 与 <code>Math.asin</code> 均是<code>类方法</code>，通过<code>类</code>(<code>Student</code>,<code>Math</code>)来调用，而<code>student.read</code>,<code>student.calculate</code> 则是 <code>Student</code> 类的 <code>student</code> 实例的<code>实例方法</code>。同样的，<code>Math.PI</code> 是 <code>Math</code> 类的<code>类变量</code>，而 <code>student.age</code> 是 <code>student</code> 实例的<code>实例变量</code>。</p>

<blockquote>
<p>关于实例变量与类变量，如果不理解可以看看 <a href="15072588525134.html">[Dive into Ruby] Ruby Basic 变量、常量以及对象</a></p>
</blockquote>

<h2 id="toc_2">Ruby 中的类(Class)</h2>

<h2 id="toc_3">Ruby 中的模块(Module)</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Dive into Ruby] Ruby Control Flow 控制语句]]></title>
    <link href="https://blog.crayygy.com/15074733157580.html"/>
    <updated>2017-10-08T22:35:15+08:00</updated>
    <id>https://blog.crayygy.com/15074733157580.html</id>
    <content type="html"><![CDATA[
<p><a href="15070154325076.html">[Dive into Ruby] Ruby 的介绍</a> 主要介绍了 Ruby 的一些特性，<a href="15072588525134.html">[Dive into Ruby] Ruby Basic 变量、常量以及对象</a> 则介绍了关于对象、变量常量的一些知识，这一篇将主要介绍 Ruby 中的程序控制语句，这一部分是每个编程语言的重点，因此会介绍的比较的详细，也会有一些小技巧。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">条件控制语句与循环控制语句</h2>

<h3 id="toc_1">条件语句 if\unless and case</h3>

<p>首先介绍一下几乎所有高级语言都有的控制语句， <code>if-else</code>。<br/>
  在 Ruby 中，<code>if</code> 判断语句跟其它语言没什么区别，如果满足一个条件，则进入一个代码块，否则进入另一个代码块，或者不执行任何操作。写起来也非常的通俗易懂。<br/>
  需要注意的是，在 Ruby 中，只有<code>false</code>与<code>nil</code>这两种情况会导致条件不满足，也就是说，只要值不是<code>false</code>或者是<code>nil</code>，<code>if</code>就是满足的。</p>

<pre><code class="language-ruby">  if condition then
    # block
  else
    # block
  end
  
  if x &gt; 10 
    # block
  end
  
  if &quot;this is a string&quot;
    # runs into here
  end
  
  if 12
    # runs into here
  end
  
  if user = User.find_by(id: uid) # 这里涉及到函数的返回值问题，后面会继续讨论
    puts user.name
  end
  
  if obj.instance_of? Object
    # runs into here
  end
</code></pre>

<p>在这里， <code>then</code> 这个关键字是可以省略的，大多数情况下都没有必要加上，少数特殊情况下不加会导致有歧义，但是也都可以改写。<br/>
  而如果程序只有<code>if</code>没有<code>else</code>的代码块，而且<code>if</code>的代码块中只有一句话，那么可以缩短成一行实现。</p>

<pre><code class="language-ruby">  do_sth if condition
</code></pre>

<p>如果是否定的语句，可以使用 <code>if not</code>，也可以使用另一个关键字<code>unless</code>，很直白的翻译成<code>除非（如果不）</code>。因此可以这样写。</p>

<pre><code class="language-ruby">  do_sth unless condition 
  
  # 等价于
  do_sth if not condition
  
</code></pre>

<p>通常使用 <code>unless</code>是在只有一个否定的代码块的时候，这个时候使用<code>unless</code>能够表达比<code>if not</code>更加清晰的逻辑，并且避免了<code>逻辑非</code>的运算。在有条件分支的时候，应该使用<code>if-else</code>的逻辑，避免将<code>unless</code>与<code>else</code> 搭配（因为这样几乎毫无意义）。</p>

<p>Ruby 中还有一种表示条件的控制语句，叫 <code>case</code>，用法基本与 Java 中的<code>Switch</code>相似。</p>

<pre><code class="language-ruby">  arr = [&quot;string&quot;, 19, nil]
  arr.each do |item|
    case item
    when String
      puts &quot;It&#39;s a string&quot;
    when Numeric
      puts &quot;It&#39;s numeric&quot;
    else
      puts &quot;It&#39;s something not string nor number&quot;
    end
  end
</code></pre>

<blockquote>
<p>Notes:<br/>
值得注意的是， <code>case-when</code> 中的比较是一种比较广泛的比较，实际上使用的是<code>===</code>比较，除了比较值之外，还会比较两边是否正则匹配，右边的对象是否属于左边的类等等。因此，在<code>case-when</code>中是可以直接使用正则表达式的。</p>
</blockquote>

<h3 id="toc_2">循环语句 while\until and more</h3>

<p>与<code>if</code>和<code>unless</code>的关系类似，<code>while</code>与<code>until</code>是一对互为否定的关系。<code>until</code> === <code>while not</code>，使用 <code>unless</code> 与 <code>until</code>的最主要目的是，使得程序更具有可读性，在看到代码的第一时刻就明白这段代码的条件所在。</p>

<pre><code class="language-ruby">  while condition do # do 可以省略
  
  end
  
  until condition do # do 可以省略
  
  end
</code></pre>

<p>在 Ruby 中，实现循环有多种方式，如 <code>for</code> 循环、<code>loop</code>循环、<code>while/until</code>循环、<code>.each</code>循环、<code>.times</code>循环等等。在不同的情况下使用不同的循环方式，能够提升程序的可读性。</p>

<p>例如，在需要某段代码执行指定次数的时候，使用 <code>n.times</code>循环会更加的直接，在需要依次访问数组的元素的时候，使用<code>array.each</code>，而在需要循环直到某个条件满足或不满足的时候，使用<code>while\until</code>循环。当然这些循环都是可以在这些场景下使用的，不同的场景使用不同的循环方式，主要是为了程序的可读性以及可理解性。</p>

<pre><code class="language-ruby">  3.times do 
    puts &quot;hello&quot;
  end
  
  students = [&#39;Andy&#39;, &#39;Bob&#39;, &#39;Cindy&#39;]
  
  students.each do |stu|
    puts stu # 通过迭代器能够更加简单的使用每一次迭代的元素
  end
  
  file = File.new(&#39;path&#39;)
  while line=file.readline
    # runs until last line
  end
</code></pre>

<p>Ruby 中的<code>for</code>循环在迭代的时候，使用的其实是 <code>.each</code> 方法，因此直接用<code>.each</code>来迭代就好了。</p>

<h4 id="toc_3">循环控制语句</h4>

<p>在循环中，有时候需要跳出当前循环，或者终止当前循环，那么就需要对应的控制语句来完成。<br/>
  Ruby 中的循环控制语句有三个 <code>break</code>、<code>next</code>还有<code>redo</code>。<code>redo</code> 用到的非常少，因此暂时不管它。<br/>
  <code>break</code> 在其它语言中也经常会见到，因此有基础的人也比较容易理解，即当执行到这个语句的时候，终止整个循环程序，进入与循环同一层次的另一段代码。而 <code>next</code>则没有这么极端，当执行到<code>next</code>的时候，当前的这次循环将会从这里被跳过，后面的语句不再执行，直接进行下一次循环。<br/>
  照样来个简单的代码来说明一下。</p>

<pre><code class="language-ruby">  
  students = [&#39;Andy&#39;, &#39;Bob&#39;, &#39;Cindy&#39;, &#39;Dave&#39;]
  
  students.each do |stu|
    if stu == &#39;Bob&#39;
      break
    end
    puts stu
  end
  # 程序运行结果: 
  # Andy
  
  students.each do |stu|
    if stu == &#39;Bob&#39;
      next
    end
    puts stu
  end
  # 程序运行结果: 
  # Andy
  # Cindy
  # Dave
</code></pre>

<p>是不是很好理解？</p>

<h3 id="toc_4">运算符优先级问题</h3>

<p>在不使用括号的情况下，各种不同的运算符拥有不同的优先级，简单的例子如，乘除法总是拥有着比加减法更高的优先级，非运算拥有比与、或运算更高的优先级。Ruby 中的运算符非常的多，不同运算符之间的优先级排序表如下。<br/>
  其中有一些需要特别注意，例如: 按位与(<code>&amp;</code>)比按位或<code>^</code>拥有更高的优先级，逻辑与(&amp;&amp;)比逻辑或(||)拥有更高的优先级。</p>

<p>在 Ruby 中，逻辑运算除了与<code>&amp;&amp;</code>或<code>||</code> 以及非<code>!</code>三种运算符之外，还有更加可读的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算符，后面三者在逻辑运算中起着与前面三者相同的作用，<strong>但是</strong>，注意这个但是，<code>and</code> <code>or</code> <code>not</code> 是拥有着更低的优先级的（仅高于控制语句），这意味着在同样的情况下，如果混用 <code>&amp;&amp;</code> 和 <code>not</code>，是会搞出大事情的。</p>

<p>因此，通常情况下，能够使用逻辑运算符 <code>&amp;&amp;\||\!</code>的时候，尽量这样使用，一方面它们的优先级较高，可以避免出现很多的问题，另一方面，使用 <code>and\or\not</code> 不太适合加括号，很多时候并没有很方便。</p>

<h4 id="toc_5">Ruby operators in precedence order.  优先级降序排列</h4>

<table>
<thead>
<tr>
<th style="text-align: center">Method</th>
<th style="text-align: center">Operator</th>
<th style="text-align: center">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">[] []=</td>
<td style="text-align: center">Element reference, element set</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">**</td>
<td style="text-align: center">Exponentiation</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">! ~ + -</td>
<td style="text-align: center">Not, complement, unary plus and minus (method names for the last two are +@ and -@)</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">* / %</td>
<td style="text-align: center">Multiply, divide, and modulo</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">+ -</td>
<td style="text-align: center">Plus and minus</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">&gt;&gt; &lt;&lt;</td>
<td style="text-align: center">Right and left ⇧</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">&amp;</td>
<td style="text-align: center">Bitwise `and&#39;</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">^</td>
<td style="text-align: center">Bitwise exclusive &#39;or&#39; and regular &#39;or&#39;</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">&lt;= &lt; &gt; &gt;=</td>
<td style="text-align: center">Comparison operators</td>
</tr>
<tr>
<td style="text-align: center">Y</td>
<td style="text-align: center">&lt;=&gt; == === != =~ !~</td>
<td style="text-align: center">Equality and pattern match operators (!= and !~ may not be defined as methods)</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">&amp;&amp;</td>
<td style="text-align: center">Logical &#39;and&#39;</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">||</td>
<td style="text-align: center">Logical &#39;or&#39;</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">.. ...</td>
<td style="text-align: center">Range (inclusive and exclusive)</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">? :</td>
<td style="text-align: center">Ternary if-then-else</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">= %= { /= -= +=</td>
<td style="text-align: center">= &amp;= &gt;&gt;= &lt;&lt;= *= &amp;&amp;=</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">defined?</td>
<td style="text-align: center">Check if symbol defined</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">not</td>
<td style="text-align: center">Logical negation</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">or and</td>
<td style="text-align: center">Logical composition</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">if unless while until</td>
<td style="text-align: center">Expression modifiers</td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">begin/end</td>
<td style="text-align: center">Block expression</td>
</tr>
</tbody>
</table>

<p>关于 Ruby 中的条件以及循环语句就介绍到这里，下一篇会介绍 Ruby 中的方法以及类的概念。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Dive into Ruby] Ruby Basic 变量、常量以及对象]]></title>
    <link href="https://blog.crayygy.com/15072588525134.html"/>
    <updated>2017-10-06T11:00:52+08:00</updated>
    <id>https://blog.crayygy.com/15072588525134.html</id>
    <content type="html"><![CDATA[
<p><a href="15070154325076.html">上一篇博客</a>主要介绍了一下 Ruby 的一些语法糖，以及作为脚本语言 Ruby 的优势所在。这一篇则开始正式介绍 Ruby 的基础语法，以及语言细节。由于 Ruby 是完全面向对象式的，因此，有 Java 基础的人能够很快的了解到 Ruby 的大部分特性，但是有一些是 Ruby 特有的，或者 Java 有而 Ruby 不支持的，这一部分会更加特别说明。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Ruby 中的对象</h2>

<p>在 Ruby 中，对象是表现数据的最基本单位。所有的对象都由 BaseObject 派生，而大部分的对象又是由 BaseObject 的子类 Object 派生。BaseObject 与 Object 类分别实现了一些所有的对象均需要的方法，例如 Object.nil? 方法（用以判断是否为空，返回 true 或者 false）等。<br/>
  Ruby 中内置了一些常用的对象类型供我们使用，例如数值对象、字符串对象、数组对象、散列对象、时间对象、文件对象，甚至正则表达式对象，等等。<br/>
  接下来会介绍一些比较常见的对象以及常用的方法。<br/>
  在介绍对象之前，先介绍一些关于变量和常量的基本知识（与其它编程语言类似）。</p>

<h3 id="toc_1">变量与常量</h3>

<p>与其它编程语言类似的，Ruby 中对变量和常量加以区分。何为变量(variable)？即变化的东西，定义一个人的年龄，<code>age = 10</code>，这是一个变量，因为人的年龄是会变的。何为常量(constant)呢？即不变的量，如定义一本书的序列号 <code>ISBN=&quot;SN12345&quot;</code>，在程序中是默认不会改变的。<br/>
  Ruby 中对于变量和常量的命名有着一些默认的规则，变量一般使用下划线命名法或者驼峰命名法，如 <code>age</code>，<code>studentNumber</code>，这样都是可以的。但通常情况下，一般的变量使用下划线命名法，而对类的实例使用驼峰命名法，这样能够更加清楚的区分变量的类型。Ruby 中的常量使用全大写命名，中间加下划线，例如 <code>MAX_NUMBER</code>。<br/>
  同时 Ruby 中又内置了一些全局的常量，例如 <code>RUBY_VERSION</code>，可以方便的在程序中调用来判断当前的环境等等。<br/>
  <strong>注意</strong>， Ruby 中的<code>常量</code>并非真正的不可改变。例如这样一段代码。</p>

<pre><code class="language-ruby">  NAME = &quot;HE&quot; # =&gt; HE
  p NAME # =&gt; HE
  NAME = &quot;SHE&quot; # =&gt; warning: already initialized constant NAME, warning: previous definition of NAME was ...
  p NAME # =&gt; SHE
</code></pre>

<p>在试图修改常量时，Ruby会报出一个 warning，表明你正在修改一个常量的值，以及常量的定义位置。但同时也会默默的修改掉常量的值。</p>

<h4 id="toc_2">变量的类型</h4>

<p>Ruby 中的变量分成四种类型，分别是局部变量(local variable)、全局变量(global variable)、实例变量(instance variable)、类变量(class variable)。<br/>
  Ruby 中对不同变量的命名也是有着默认的规范的。<br/>
  局部变量以小写字母或者<code>_</code>开头，<br/>
  全局变量以<code>$</code>开头，<br/>
  实例变量以<code>@</code>开头，<br/>
  类变量以<code>@@</code>开头。</p>

<p>还有一种类型，叫做 伪变量，例如 nil\self\true\false 等等。伪变量是 Ruby 中预先定义好的表示某些特定值的特殊变量，即使我们在程序中人为的去改变，也不会生效。伪变量虽然看着像是变量，但是实际行为与变量有很多不同的地方。</p>

<p>要怎样去理解这些类型呢，其实很简单，看这些变量的作用域，以及谁来调用就可以了。<br/>
  对于局部变量和全局变量，可以参考这样一段代码。</p>

<pre><code class="language-ruby">  $name = &quot;Ruby&quot;
  
  def hello name
    greeting = &quot;hello&quot;
    puts &quot;#{greeting} #{name}&quot;
  end
  
  my_name = &quot;Cray&quot;
  hello my_name # =&gt; hello Cray
  hello $name  # =&gt; hello Ruby
</code></pre>

<p>在这段代码中， <code>$name</code>是一个全局变量，在这个例子中并没有体现出它作为全局变量的能力，但是当这段代码被其它代码调用时，整个程序中共享着同一个全局变量 <code>$name</code>，因此可以在其它地方修改，调用。<br/>
  而<code>my_name</code>是一个局部变量，这意味着它只能在整个程序的这个部分使用，如果你在另一个地方使用<code>my_name</code>，你用的变量跟这个完全没有任何关系。<br/>
  对于 <code>greeting</code> 这个变量，则是 <code>hello()</code> 这个函数的一个局部变量，只能在函数内使用，函数外无法调用。<br/>
  <strong>注意</strong>，通常不建议在程序中过多的使用全局变量，因为这样会无法保证是否有其它地方修改过这些变量，会给 debug 带来非常大的麻烦，而且在多线程调用的时候，也无法保证全局变量的共享问题。因此，给自己省点麻烦，除非迫不得已，否则尽量不用。</p>

<p>那么对于实例变量和类变量呢？写过 Java 的人应该都知道，Java 中的变量有 <code>static</code> 与 <code>non static</code>的区别， <code>static</code> 的变量，可以通过<code>类名.对象名</code>来使用，例如 <code>Math.PI</code>，而<code>non static</code>的变量，则需要创建一个类的实例，通过实例来调用。Ruby 中的实例变量与类变量与 Java 中无异，实例变量需要通过类的实例去调用，而类变量则是通过类自身去调用。这就是它们之间的差别。<br/>
  同样的区别也会发生在实例方法与类方法中，后面会详细介绍。</p>

<p>好的，介绍完了变量类型，接下来继续介绍对象。</p>

<h3 id="toc_3">Ruby 中常用的对象</h3>

<p>在编程语言中，最基础的功能就应当是数的表达与运算，整型数、浮点数，加、减、乘、除等等。在 Ruby 中使用数值的方法与其它语言无异，但是有一点需要注意，在 Ruby 中，以加法为例：</p>

<pre><code class="language-ruby">a = 3
b = 4
c = a + b
</code></pre>

<p>其中 <code>c = a + b</code>，这里的 <code>+</code>，其实是 <code>a.add(b)</code> 的一个语法糖，等效于调用对象 <code>a</code> 的方法。</p>

<p>还有一点需要注意的是，在 Ruby 中，<code>1 == 1.0</code> 的返回值是 <code>true</code>，因为这里的<code>==</code>方法被重写了，在这里数值的 <code>==</code> 方法实现的是值比较，所以返回的是 <code>true</code>，而如果是 <code>eql?</code> 方法，<code>1.eql? 1.0</code>，返回的则是 <code>false</code>。 <code>equals?</code> 方法与 <code>eql?</code> 方法是不能够被子类所重写的，永远比较的是对象的引用，而不是值。</p>

<p>同样的，字符串对象的使用也很简单。在字符串对象中可以通过 <code>#{}</code> 来注入变量与方法。</p>

<pre><code class="language-ruby">name = &quot;Ruby&quot;
greeting = &quot;hello #{name}&quot;
  
def hello name
return &quot;hello #{name}&quot;
end
  
puts &quot;Welcome, #{hello &#39;Ruby&#39;}&quot;
</code></pre>

<p>Ruby 中的数组对象和散列对象内置了一些方便方法，如迭代器，排序等等。例如向数组中添加一个新的元素。</p>

<pre><code class="language-ruby">arr = []
arr &lt;&lt; &quot;Andy&quot;
arr.append &quot;Bob&quot;

# 创建一个新的hash
hash = Hash.new
hash[:name] = &quot;Andy&quot;
hash[:age] = 19
hash[:grade] = 3

puts hash[:name]
</code></pre>

<p>其它的像时间对象、文件对象的使用方法也都比较简单，可以通过API文档查询使用方法，这里就不过多介绍了。</p>

<p>关于 Ruby 中的变量常量以及对象就介绍这么多，下一篇会开始介绍 Ruby 中的控制流，<code>if</code> <code>unless</code> <code>when</code> <code>while</code> <code>until</code>等等，再后面会介绍 Ruby 中方法，以及类(class)与类的继承(inheritance)，还有模块(module)相关的概念。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Dive into Ruby] Ruby 的介绍]]></title>
    <link href="https://blog.crayygy.com/15070154325076.html"/>
    <updated>2017-10-03T15:23:52+08:00</updated>
    <id>https://blog.crayygy.com/15070154325076.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0"><a href="https://www.ruby-lang.org/en/">Ruby</a> is</h3>

<blockquote>
<p>A dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>其实从官网的描述我们已经能够知道，Ruby 是一门开源的脚本语言，并且强调的是写代码时的效率以及可读性等等，并没有刻意强调执行效率（当然，这并不代表执行效率不够高）。Ruby 是一门非常注重编码人员体验的语言， Ruby 之父也曾表示， Ruby最初诞生的一个目标就是: &quot;Happy coding&quot;。</p>

<p>作为脚本语言目前最广为人知的是 Python，在各个领域都大放异彩，从 Linux shell script，到 Web development，再到越来越火爆的 Data mining, AI, Science computing。Python 由于其非常完善的第三方库资源以及社区资源而著称。</p>

<p>而同样作为脚本语言的 Ruby，最广为人知的则是 Web Development， Ruby on Rails 框架可以说是快速开发的典型代表，一个简单的网站可以用几十行代码，甚至于只需要配置一下数据库，再用 rails 命令执行几个命令即可完成，非常的方便。但 RoR 的火爆，有利也有弊，很多人因此而开始了 Ruby 的使用，而很多人也因此给 Ruby 打上了 &quot;Web&quot; 这个标签。事实上，Ruby 作为脚本语言，Python 能够完成的大多数事情，Ruby 也能完成的很好甚至更好，但由于第三方库的缺失以及社区生态的原因，国内使用 Ruby 的人并不是很多，而且其中绝大部分也都是从事着 RoR 开发。</p>

<p>作为一名 Ruby 爱好者，我想，我应该把我知道的关于 Ruby 的事情写下来。如果有不对的地方，还望不吝赐教。 🙏</p>

<p>Dive into Ruby 会是一个系列，我会尽可能的写完每一篇。</p>

<h3 id="toc_1">Ruby 初探</h3>

<p>在我眼里，Ruby 与其它语言（C++, Java, Python, Javascript等) 一个很大的区别是，Ruby是一个 <strong>完全</strong> 面向对象的语言。<br/>
  何为完全？ 比如说在 Java 中，数据类型分成几种，一种叫基本数据类型(primitive type)，例如 <code>int</code>, <code>float</code>, <code>boolean</code>, <code>char</code>, 这样的，另一种则是对象(Object)，例如 String 是一个字符串对象，Integer 是整型的对象。 这两者完全不同的两类。而在 Ruby 中，所有的一切都是对象(Object)，因此一个整数 <code>10</code> 是一个对象， <code>a = 10</code>，也就声明了一个值为<code>10</code>的对象<code>a</code>。这样做的意义是什么呢？举个例子。</p>

<p>比如你可以在 Ruby 中这样去写一个循环：</p>

<pre><code class="language-ruby">  # 循环输出10次 “hello world”
  10.times do 
     puts &quot;hello world&quot;。# =&gt; hello world
  end
</code></pre>

<p>怎么样，是不是很直白明了。再比如，在 Ruby 中你可以这样去声明和计算时间。</p>

<pre><code class="language-ruby">  duration = 1.year
  one_hour = 60.mins
  one_day = 24.hours
  one_week = 7.days
</code></pre>

<p>看起来怎么样？<br/>
  再来一个比较常用的，数组对象，怎么样遍历数组呢？ <code>for</code> 循环吗？你可以这样：</p>

<pre><code class="language-ruby">  students = [&quot;Andy&quot;, &quot;Bill&quot;, &quot;Cindy&quot;]
  students.each do |stu|
    puts stu
  end
</code></pre>

<p>当然了， for 循环也不是不可以，只是 Ruby 不推荐使用 for 循环，因为 for 循环本身的实现也是使用 <code>迭代器(iterator)</code>，因此使用 for 循环有点多此一举的感觉。</p>

<pre><code class="language-ruby">  for stu in students 
    puts stu
  end
  
  for i in 0..5
    puts &quot;value of i is: #{i}&quot;
  end
</code></pre>

<p>等等，Ruby 中的字符串可以这样用的？</p>

<p>是的，Ruby 中允许在字符串中使用变量，甚至于调用方法，只需要用 <code>#{}</code> 来标记即可。</p>

<p>Ruby 中还有一个概念，叫<code>符号(Symbol)</code>。 符号有什么用呢？还是用一个例子来说明。</p>

<p>如果我需要创建一个 Hash， 来记录每个省份的省会， 我可以这样写。</p>

<pre><code class="language-ruby">  provinces = Hash.new
  provinces[&quot;Anhui&quot;] = &quot;Hefei&quot;
  provinces[&quot;Jiangxi&quot;] = &quot;Nanchang&quot;
</code></pre>

<p>这里的 Hash 表， Key 的类型是字符串，因此在需要使用的时候，要用字符串来调用。</p>

<pre><code class="language-ruby">  puts provinces[&quot;Anhui&quot;]
</code></pre>

<p>而通常来说，省份名字是比较的固定的，而且每次用到的时候也都只有那几种，因此我们可以用 Symbol 来作为 Key。创建一个 Symbol 非常的简单，一个冒号<code>:</code>加上 Symbol 的名字就可以了，使用起来也一样。</p>

<pre><code class="language-ruby">  provinces = Hash.new
  provinces[:Anhui] = &quot;Hefei&quot;
  provinces[:Jiangxi] = &quot;Nanchang&quot;
  
  puts provinces[:Anhui] # =&gt; Hefei
</code></pre>

<p>那么使用 Symbol 和 使用 String 有什么不同呢？</p>

<p><strong>Attention please</strong></p>

<p>Ruby 中同一个 Symbol 总是指向同一个 Symbol 对象，而多个 String 则是不同的 String 对象，哪怕它们的值是相同的。听起来是不是有点像 Java 中的字符串对象？<br/>
  照样的还是例子，我们通过 Ruby 中对象的唯一标识符(Object Identifier)来判断是不是同一个对象。</p>

<pre><code class="language-ruby">  puts :sym.object_id # =&gt; 781148
  puts :sym.object_id # =&gt; 781148
  puts :sym.object_id # =&gt; 781148
  
  puts &quot;str&quot;.object_id # =&gt; 70145943017540
  puts &quot;str&quot;.object_id # =&gt; 70145943017480
  puts &quot;str&quot;.object_id # =&gt; 70145943017420

</code></pre>

<p>这样是不是就清楚很多啦？</p>

<p>好了，第一篇先写这么多，剩下的留着后面慢慢写～</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keep three decimal places and throw the third if it's "0"]]></title>
    <link href="https://blog.crayygy.com/15023766649409.html"/>
    <updated>2017-08-10T22:51:04+08:00</updated>
    <id>https://blog.crayygy.com/15023766649409.html</id>
    <content type="html"><![CDATA[
<p>For example:</p>

<blockquote>
<p>14.98812 -&gt; 14.988<br/>
1.8731312 -&gt; 1.873<br/>
2.33045 -&gt; 2.33</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>script in perl:</p>

<pre><code class="language-perl">$price =~ s/(\.\d\d[1-9]?)\d*/$1/
</code></pre>

<p>Explain:</p>

<blockquote>
<p><code>\.</code>matches the point</p>

<p><code>\d\d</code> matches the first two digits<br/>
<code>[1-9]?</code> matches the third digit if it&#39;s between 1 to 9</p>
</blockquote>

<p>match all above as a group, in perl, can use $1 to identical the group first</p>

<blockquote>
<p><code>\d*</code> to match all the rest digits if exists.</p>
</blockquote>

<p>at last, replace the matched string(e.g. 1.231323131) and replace with the first matched group(the 3 useful digits if the third one is not 0).</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Sample code of 2d Hash set]]></title>
    <link href="https://blog.crayygy.com/15007372838208.html"/>
    <updated>2017-07-22T23:28:03+08:00</updated>
    <id>https://blog.crayygy.com/15007372838208.html</id>
    <content type="html"><![CDATA[
<p>In fact, this can be a n dimension hash set code sample, actually I create a 3-d hash to construct some kind of data structure for API rendering, it&#39;s not so beautiful, but easy to work, and not cost so much.</p>

<span id="more"></span><!-- more -->

<pre><code class="language-ruby">first_hash_key = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]
second_hash_key = [&#39;a&#39;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
hash = Hash.new
first_hash_key.each do |key|
  hash[key] = Hash.new
end
p hash

# {&quot;A&quot;=&gt;{}, &quot;B&quot;=&gt;{}, &quot;C&quot;=&gt;{}, &quot;D&quot;=&gt;{}}

first_hash_key.each do |key|
  second_hash_key.each do |k|
    if hash[key][k].nil?
      hash[key][k] = 1
      # p hash[&quot;A&quot;][k]
    else
      hash[key][k] += 1
    end
  end
end
p hash
# {&quot;A&quot;=&gt;{&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;1, &quot;c&quot;=&gt;1, &quot;d&quot;=&gt;1}, &quot;B&quot;=&gt;{&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;1, &quot;c&quot;=&gt;1, &quot;d&quot;=&gt;1}, 
# &quot;C&quot;=&gt;{&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;1, &quot;c&quot;=&gt;1, &quot;d&quot;=&gt;1}, &quot;D&quot;=&gt;{&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;1, &quot;c&quot;=&gt;1, &quot;d&quot;=&gt;1}}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails + Mongodb + AngularJS develop environment setup]]></title>
    <link href="https://blog.crayygy.com/14890186322971.html"/>
    <updated>2017-03-09T08:17:12+08:00</updated>
    <id>https://blog.crayygy.com/14890186322971.html</id>
    <content type="html"><![CDATA[
<p>Before start, make sure that:<br/>
1. You are using macOS or Ubuntu 14.04(or higher)</p>

<ol>
<li>basic system tools like git are installed. If you are using macOS, make sure you have Xcode/ Xcode Tool Chain installed.</li>
</ol>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Installation guide</h2>

<h3 id="toc_1">Install Ruby and Rails</h3>

<p>Check this guide on ruby-china(<a href="https://ruby-china.org/wiki/install_ruby_guide">https://ruby-china.org/wiki/install_ruby_guide</a>)</p>

<p>some advice</p>

<ol>
<li><p>use rvm or rbenv for better performance.</p></li>
<li><p>use ⌘ <code>gem install rails -v 4.1.4</code> will install the specific version of rails.</p></li>
</ol>

<h3 id="toc_2">Install Mongodb</h3>

<p>Follow this guide on mongodb.org (<a href="https://docs.mongodb.com/manual/installation/">https://docs.mongodb.com/manual/installation/</a>)</p>

<blockquote>
<p>If you are using macOS, try use <em>homebrew</em> for all the installation. <br/>
<code>brew install mongodb</code></p>
</blockquote>

<h3 id="toc_3">Install angularjs</h3>

<p>We are using bower for front-end js package management, so you should install nodejs and use npm install bower first.</p>

<ol>
<li><p>install node and npm. check documents on <a href="https://nodejs.org/en/">https://nodejs.org/en/</a> </p>

<blockquote>
<p>Try to use <a href="https://github.com/creationix/nvm">nvm</a> instead of install from the website. Official installer may cause npm not work. (This may be a bug, I have encounter this on macOS and Ubuntu many times).  If you installed this official build, and encounter the same problems, JUST USE <em>NVM</em>.<br/>
nvm guide:<br/>
1. use the script to install nvm. (The script is shown on nvm GitHub project).<br/>
2. use <code>nvm install &lt;version&gt;</code> to install a specific version of node. for example: <code>nvm install 6.10.0</code>.<br/>
3. use <code>nvm alias default &lt;version&gt;</code> to make this node version as your default version, so you don&#39;t need to choose every time you open a new terminal.<br/>
4. use <code>node -v</code> and <code>npm -v</code> to check whether  you have these tools installed.<br/>
5. now you can use <code>npm install</code> ⌘ to install node packages.</p>
</blockquote></li>
<li><p>install bower using npm <code>npm install -g bower</code> check documents on <a href="https://bower.io/#install-bower">https://bower.io/#install-bower</a></p></li>
</ol>

<h3 id="toc_4">SSH key</h3>

<p>ssh key is used to communicate with gitlab server, follow these steps:</p>

<ol>
<li><p>open your terminal and run ⌘ <code>ssh-keygen -t rsa</code></p></li>
<li><p>just use default options and set no password, and ssh key will be generated.</p></li>
<li><p>run ⌘ <code>cat ~/.ssh/id_rsa.pub</code>, copy the ssh key, and add it to your github account.</p></li>
</ol>

<h2 id="toc_5">Run guide</h2>

<p>make sure you have <em>git</em> <em>ruby</em> <em>rails</em> <em>mongodb</em> <em>bower</em> installed first.</p>

<ol>
<li><p>git clone </p></li>
<li><p>cd to project folder and run ⌘ <code>bundle install</code></p></li>
<li><p>run ⌘ <code>bower install</code></p></li>
<li><p>run ⌘ <code>rails s</code> - this is for development, if you wanna run rails in production mode, use <code>rails s -e production</code>.</p>

<blockquote>
<p><code>-e</code> is used to environments,  default is development.</p>
</blockquote></li>
<li><p>check output.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Mongodb problems and solutions]]></title>
    <link href="https://blog.crayygy.com/14842384827556.html"/>
    <updated>2017-01-13T00:28:02+08:00</updated>
    <id>https://blog.crayygy.com/14842384827556.html</id>
    <content type="html"><![CDATA[
<p>Recently I have encountered some problems during my internship. One of our server suddenly goes very very slow, when I try to ping the server, it&#39;s always 2000-5000. After checked everything I think may cause the problem and got no answer, I decided to reboot the server.</p>

<span id="more"></span><!-- more -->

<p>After hard reboot the virtual machine, it&#39;s just the start of the hell. First, I found there&#39;s some warning about ruby, then, the mongodb on the server can&#39;t restart after reboot. </p>

<p>Luckily, we have already backup our data since one time that we delete our database without &quot;where&quot;.  We backup our database every two hours to another server. So nothing too bad happens.</p>

<p>Mongodb is such a nasty guy, when I try to restart with ⌘ <code>mongod -f /etc/mongod.conf --fork</code>, it got stuck. And never showed a single message. At last, I had to delete my exist db and pull it back from our backup server, and then put it into another folder, and re-write the config file, change dbpath parameter, and start with ⌘ <code>mongod -f /etc/mongod.conf --fork</code>.</p>

<p>Something good about mongo is that it can set a master db and a slave db for backup.  For this, all you have to do is start mongo with a config file, and set <code>master=true</code> or <code>slave=true</code> in config file.</p>

<p>For example, on you master db server, you should write config file like this:</p>

<pre><code>dbpath=[a-folder]
logpath=[a-folder]
master=true
...
...
</code></pre>

<p>On your slave db server, you should write mongo config file like this<br/>
port=<a href="27018">a-port-different-from-master-db</a><br/>
dbpath=[some-place-to-store-db]<br/>
logpath=[some-place-to-store-log]<br/>
slave=true<br/>
slavedelay=7200// set as seconds<br/>
source=[master-db-ip-address]:[master-db-port]</p>

<p>After start both server, your mongodb will sync from you master server to your slave server every 2 hours.</p>

<p>Some tricks about mongod ⌘</p>

<p>Usually start with --dbpath parameter, or use --config(-f as abbr) to start with a config file.</p>

<p>--fork parameter can let mongod server runs on the background.</p>

<p>A single example of this is:<br/>
<code>mongod -f /etc/mongod.conf --fork</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode #169 Majority Element]]></title>
    <link href="https://blog.crayygy.com/14698658453148.html"/>
    <updated>2016-07-30T16:04:05+08:00</updated>
    <id>https://blog.crayygy.com/14698658453148.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
</blockquote>

<span id="more"></span><!-- more -->

<blockquote>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>

<p>Build a hash for the result, if a num is not in the hash, then make the hash[num] counts 1, else make the hash[num]+1.</p>

<p>To get the majority element of the array, just get the key with the max value in this hash.</p>

<pre><code class="language-ruby"># @param {Integer[]} nums
# @return {Integer}
def majority_element(nums)
  hash = Hash.new
  
  nums.each do |num| 
    if hash.has_key? num
      hash[num] += 1
    else
      hash[num] = 1
    end
  end
  result = hash.key(hash.values.max)
  return result
end
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode #338 Counting Bits]]></title>
    <link href="https://blog.crayygy.com/14697688870593.html"/>
    <updated>2016-07-29T13:08:07+08:00</updated>
    <id>https://blog.crayygy.com/14697688870593.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&#39;s in their binary representation and return them as an array.</p>
</blockquote>

<span id="more"></span><!-- more -->

<blockquote>
<p>Example:<br/>
For num = 5 you should return [0,1,1,2,1,2].</p>

<p>Follow up:<br/>
It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br/>
Space complexity should be O(n).<br/>
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p>
</blockquote>

<p>首先，在规定的时间复杂度下，不可能进行每一步都计算，因此考虑到 2<sup>n-1</sup> 与 2<sup>n</sup> 时的关联，利用前 2<sup>n-1</sup> 次方去推导后面2<sup>n</sup> 位。</p>

<p>考虑前16位: </p>

<pre><code>[0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
</code></pre>

<p>从二进制表示法开始入手， 如下:</p>

<table>
<thead>
<tr>
<th style="text-align: center">十进制</th>
<th style="text-align: center">二进制</th>
<th style="text-align: center">十进制</th>
<th style="text-align: center">二进制</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">0</td>
<td style="text-align: center">0</td>
<td style="text-align: center">8</td>
<td style="text-align: center">1000</td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">01</td>
<td style="text-align: center">9</td>
<td style="text-align: center">1001</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">10</td>
<td style="text-align: center">10</td>
<td style="text-align: center">1010</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">11</td>
<td style="text-align: center">11</td>
<td style="text-align: center">1011</td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: center">100</td>
<td style="text-align: center">12</td>
<td style="text-align: center">1100</td>
</tr>
<tr>
<td style="text-align: center">5</td>
<td style="text-align: center">101</td>
<td style="text-align: center">13</td>
<td style="text-align: center">1101</td>
</tr>
<tr>
<td style="text-align: center">6</td>
<td style="text-align: center">110</td>
<td style="text-align: center">14</td>
<td style="text-align: center">1110</td>
</tr>
<tr>
<td style="text-align: center">7</td>
<td style="text-align: center">111</td>
<td style="text-align: center">15</td>
<td style="text-align: center">1111</td>
</tr>
</tbody>
</table>

<p>对于任意 x， 我们可以把 x 拆成一个最大的 2<sup>n-1</sup> + 一个数(n表示当前二进制的位数)，比如:</p>

<p>\[5 = 2^2 + 2^0 + 0\\\<br/>
6 = 2^2 + 2^1 + 0\\\<br/>
14 = 2^3 + 6 = 2^3 + 2^2 + 2^1 + 0\]</p>

<p>因此在计算 x 的二进制中 1 的个数的时候，如计算 <code>5(= 101)</code>，可以通过计算 <code>1</code> 中 1 的个数，然后加上二进制最高位的1，这样就可以不需要计算每一个的二进制，直接通过前 <code>2^n-1</code>来计算。</p>

<p>因此核心算法如下:</p>

<p>\[f(x) = f(x - 2^n) + 1\]</p>

<p>最后加上的 1 即为二进制最高位的 1.<br/>
Python 代码如下：</p>

<pre><code class="language-python">class Solution(object):
    def countBits(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: List[int]
        &quot;&quot;&quot;
        array = [0]
        flag = 0 # current level
        target = num + 1
        for i in range(1, target):
            if i % pow(2, flag+1) == 0:
                flag+=1 #if a num is 2^n, then level++
            array.append(array[i-pow(2, flag)] + 1)
        
        return array
</code></pre>

<p><img src="media/14697688870593/14697691172660.jpg" alt=""/></p>

<p>算法复杂度不是很好，其中需要算平方的部分可能耗时比较多，不过相对于一个个去算已经提高了很多了。</p>

<p>应该还是有提升的空间的，需要进一步思考。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数组乱序算法]]></title>
    <link href="https://blog.crayygy.com/14639202546153.html"/>
    <updated>2016-05-22T20:30:54+08:00</updated>
    <id>https://blog.crayygy.com/14639202546153.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>给定一个已知数组<code>array[]</code>， 将 <code>array[]</code> 乱序后输出。<br/>
可以延伸为:例如，从 0～1000 中随机取数字100次，要求每次的结果不能相同。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>这道题的想法来自于遇到的一个小问题，需要将一组包含20个字符串的数组乱序输出。</p>

<h4 id="toc_0">0x00</h4>

<p>第一想法是，简单的从数组中取元素，然后加入到另一个数组中，加入之前判断这个元素是否已经存在。<br/>
这个算法的问题在于，运行初期，遇到问题的几率比较小，然而在判断最后几个元素的时候，由于巨大的碰撞几率(n个元素的数组，当第 n 个元素的时候，其实只有 \( \frac{1}{n} \) 的机会得到正确的结果)，当数组长度达到一定程度时，几乎无法使用。</p>

<h4 id="toc_1">0x01</h4>

<p>结合查到的资料，得到这样的一个算法。即: </p>

<blockquote>
<p>每次从已知数组中<code>随机</code>取一个元素放入新数组，然后将最后一个元素的值赋给这个位置，将长度减1，然后再从 <code>length-1</code> 个元素中重复上述动作，即可得到一个随机数组。</p>
</blockquote>

<p>这个算法的强势在于，时间复杂度为 \(O(n)\)，并且避开了可能出现的碰撞，实现了快速乱序。<br/>
下面是这个算法的 Java 实现(为了表述方便选择了 int 型的数组)</p>

<pre><code class="language-java">class RandomArray{
    public static int[] shuffle(int[] array) {
        int length = array.length;
        int[] shuffledArray = new int[length];

        int index = 0;

        java.util.Random random = new java.util.Random();
        for (int count=length; count&gt;0; count--) {
            int randomIndex = Math.abs(random.nextInt())%(count);
            shuffledArray[index] = array[randomIndex];
            index += 1;
            array[randomIndex] = array[count-1];
        }
        return shuffledArray;
    }
}
</code></pre>

<p>可以在这个类中增加一个测试方法:</p>

<pre><code class="language-java">    public static void printArray(int[] array){
        int len = array.length;
        for (int i=0; i&lt;len; i++) {
            System.out.print(array[i] + &quot; &quot;);
        }
        System.out.println(&quot;😀&quot;);
    }


    public static void main(String[] args) {
        int array[] = {1,2,3,4,5,6,7,8,9,0,213,123,23,1,23};
        printArray(array);

        printArray(shuffle(array));

    }
</code></pre>

<p>每次运行时产生的随机数序列都是不同的，如果需要每次运行结果相同，可以修改随机数生成算法，使得每次运行时都能得到相同的随机数序列。</p>

<h4 id="toc_2">0x02</h4>

<p><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a></p>

<blockquote>
<p>The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite set—in plain terms, the algorithm shuffles the set. The algorithm effectively puts all the elements into a hat; it continually determines the next element by randomly drawing an element from the hat until no elements remain. The algorithm produces an unbiased permutation: every permutation is equally likely. The modern version of the algorithm is efficient: it takes time proportional to the number of items being shuffled and shuffles them in place.<br/>
From wikipedia</p>
</blockquote>

<p>Fisher-Yates 算法不需要新建一个数组来保存随机后的数组，而是直接在数组中进行操作，并且时间复杂度依然是 \(O(n)\)</p>

<p>Wiki 上提供的一个伪代码如下:</p>

<pre><code>-- To shuffle an array a of n elements (indices 0..n-1):
for i from 0 to n−2 do
     j ← random integer such that 0 ≤ j &lt; n-i
     exchange a[i] and a[i+j]
</code></pre>

<p>算法思想很简单，在具有 n 个元素的数组中，从 0 到 n-2 依次进行与一个随机位置的元素进行交换。<br/>
将伪代码改写成 Java 代码:</p>

<pre><code class="language-java">public static int[] fisherShuffle(int[] array) {
        int length = array.length;
        java.util.Random random = new java.util.Random();
        for (int i=0;i&lt;length-1; i++) {
            int j = Math.abs(random.nextInt())%(length-i);
            int temp = array[i];
            array[i] = array[i+j];
            array[i+j] = temp;
        }

        return array;
    }
</code></pre>

<p>运行结果如下: <br/>
<img src="media/14639202546153/14642385093605.jpg" alt=""/></p>

<h4 id="toc_3">0x03</h4>

<p>当然如果使用像 Ruby 这样的语言，已经内置好了 shuffle 算法，只需要直接调用即可。</p>

<pre><code class="language-ruby">array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print  array
puts 
print array.shuffle
puts
</code></pre>

<p><img src="media/14639202546153/14642385924669.jpg" alt=""/></p>

<p>简直黑科技...</p>

<p>让我们大喊一声: “Ruby 大法好！”</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬楼梯算法分析详解及扩展(最大步长从2升级为m)]]></title>
    <link href="https://blog.crayygy.com/14599905787744.html"/>
    <updated>2016-04-07T08:56:18+08:00</updated>
    <id>https://blog.crayygy.com/14599905787744.html</id>
    <content type="html"><![CDATA[
<p>几天前在公司面试的时候，第二轮的面试官问了我几道算法题，第一题是Nil Game，因为之前在Leetcode上刷过这题，也在《编程之美》上看到过几种解法，很轻松就给出了正确答案。第二题问的是爬楼梯问题，即一个N阶的楼梯，每次能走1～2阶，问走到N阶一共多少种走法。之前在Leetcode上也刷过<a href="https://leetcode.com/problems/climbing-stairs/">Link</a>，面试的时候临时也想了几种不同的方法去解，回来之后又思考了一番，想出了如下几种解法。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">本文目录</h2>

<ul>
<li>
<a href="#toc_0">本文目录</a>
</li>
<li>
<a href="#toc_1">递归解法</a>
</li>
<li>
<a href="#toc_2">表达式法</a>
</li>
<li>
<a href="#toc_3">动态规划的数组实现</a>
</li>
<li>
<a href="#toc_4">队列实现</a>
</li>
<li>
<a href="#toc_5">矩阵算法</a>
</li>
<li>
<a href="#toc_6">扩展: N阶楼梯，每步可走0～m步，求解算法</a>
</li>
</ul>


<h2 id="toc_1">递归解法</h2>

<p>首先最直观的方法当然是递归求解。因为每次只能走1或2阶，因此，走上第n阶的走法应该等于第n-1阶和n-2阶的和(先走到第n-2阶然后走两阶，或者先走上第n-1阶然后走一阶)。利用 \[\\f(n) = f(n-1) + f(n-2)，f(0) = 1，f(1) = 1\]直接求解。</p>

<pre><code class="language-java">public class Solution {
    public int climbStairs(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        return climbStairs(n-1) + climbStairs(n-2);
    }
}
</code></pre>

<p><img src="media/14599905787744/14602749249993.jpg" alt=""/></p>

<p>随便给了几个测试用例，都是通过的，但是递归解法实在是太消耗资源了，因此在提交答案的时候我们会看到...<br/>
<img src="media/14599905787744/14602750216512.jpg" alt=""/><br/>
啊哦，超时了。<br/>
我们不可能局限于递归解法，因此如何对这个算法进行优化，成为了现在需要思考的问题。<br/>
PS: 如果你在面试中用了这个解法，并且没有提到说要用其他算法进行优化的话...请节哀。</p>

<h2 id="toc_2">表达式法</h2>

<p>高中学二阶数列的时候学过类似的问题，即汉诺塔问题(<a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">Link</a>)，当时不会计算机，得到的解法是 \(f(n) = 2＊f(n-1)+1\)，直接求出通项公式，代入求解。</p>

<p>对于爬楼梯算法，我们只需要求解下面这个数列的通项公式:<br/>
\[f(n) =\<br/>
\begin{cases} <br/>
f(n-1)+f(n-2)  &amp; n&gt;2 \\\<br/>
1 &amp; n=0, 1<br/>
\end{cases}<br/>
\]</p>

<p>使用数学方法可以解出 \(f(n)\)的通项公式，代入求解即可，时间复杂度为\(O(1)\)，空间复杂度，呃...和其他的相比几乎没有吧。</p>

<p>但是这种方法很不好，因为把计算的过程交给了人来完成。我们使用计算机的一个理由就是为了利用计算机解决计算问题，节约人的时间，如此算法太过于本末倒置。因此我们需要一种算法，既解决了人计算的步骤，也让计算机拥有快速的运行时间复杂度。</p>

<h2 id="toc_3">动态规划的数组实现</h2>

<p>使用数组解法，我们需要创建一个大小为n+1的数组。如果说递归解法是自顶向下的话，数组实现动态规划即是自底向上。在这个算法中，和递归解法类似，只是将<code>f(n)=f(n-1)+f(n-2)</code>换成 <code>result[n] = result[n-1]+result[n-2]</code>即可。</p>

<pre><code class="language-java">public class Solution {
    public int climbStairs(int n) {
        int[] result = new int[n];
        result[0] = 1;
        if( n&gt;= 2) {
            result[1] = 2;
        }
        for(int i = 2; i &lt; n; i++){
            result[i] = result[i-1] + result[i-2];
        }
        return result[n-1];
    }
}
</code></pre>

<p><img src="media/14599905787744/14602778120512.jpg" alt=""/></p>

<p>采用数组实现的时间复杂度为\(O(n)\)，空间复杂度为\(O(n)\)。</p>

<h2 id="toc_4">队列实现</h2>

<p>注意观察公式 \[f(n)=f(n-1)+f(n-2)\] 当求解到第n项的时候，我们实际上只需要前面两项的值，在计算第n-1项的时候，事实上需要的是第n-1项和第n项，从始至终我们接触到的值都只有三个。</p>

<p>因此，考虑一种队列实现，这个队列共有三个元素，第一个元素我们可以看成是 \(f(n-2)\)，第二个元素看成是\(f(n-1)\)，第三个元素看成是\(f(n)\)。</p>

<table>
<thead>
<tr>
<th>第一项</th>
<th>第二项</th>
<th>第三项</th>
</tr>
</thead>

<tbody>
<tr>
<td>\(f(n-2)\)</td>
<td>\(f(n-1)\)</td>
<td>\(f(n)\)</td>
</tr>
</tbody>
</table>

<p>在计算到 \(f(n+1)\)时，我们只需要将\(f(n-2)\)出队列，然后将\(f(n+1)\)入队列，此时的队列既变成了 \(f(n-1)\)，\(f(n)\)和\(f(n+1)\)。计算方法和数组实现类似。</p>

<table>
<thead>
<tr>
<th>第一项</th>
<th>第二项</th>
<th>第三项</th>
</tr>
</thead>

<tbody>
<tr>
<td>\(f(n-1)\)</td>
<td>\(f(n)\)</td>
<td>\(f(n+1)\)</td>
</tr>
</tbody>
</table>

<p>通过队列，我们成功的将空间复杂度降为\(O(1)\)(因为只用了三个元素空间来实现队列)，但是时间复杂度仍旧不变。<br/>
当然这种解法也可以通过一个大小为3数组来实现，只是在数组中我们在将第0个元素移除的时候，需要自己实现前移的过程，较为繁琐。<br/>
或者我们也可以使用三个变量num1,num2,num3来实现，只是这样一来的话，三个变量需要赋值转换，增加阅读难度。</p>

<h2 id="toc_5">矩阵算法</h2>

<p>构建一个矩阵<br/>
\[\begin{align}<br/>
\begin{bmatrix}<br/>
x_{n} \\<br/>
x_{n-1}<br/>
\end {bmatrix}<br/>
&amp;= \begin{bmatrix}<br/>
x_{n-1} + x_{n-2} \\<br/>
x_{n-1}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\\<br/>
1 &amp; 0 <br/>
\end{bmatrix} * <br/>
\begin{bmatrix}<br/>
x_{n-1} \\<br/>
x_{n-2}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{2} * <br/>
\begin{bmatrix}<br/>
x_{n-2} \\<br/>
x_{n-3}<br/>
\end{bmatrix}\\<br/>
&amp; \dots \\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{n-1} * <br/>
\begin{bmatrix}<br/>
x_{1} \\<br/>
x_{0}<br/>
\end{bmatrix}\\<br/>
&amp;=\begin{bmatrix}<br/>
1 &amp; 1 \\<br/>
1 &amp; 0 <br/>
\end{bmatrix}^{n-1} * <br/>
\begin{bmatrix}<br/>
1 \\<br/>
1<br/>
\end{bmatrix}\\<br/>
\end{align}<br/>
\]</p>

<p>在计算 \(x_{n}\)的时候，我们只需要直接计算矩阵\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-1}\)即可。<br/>
这样，我们的主要问题就转换成了求矩阵的n次方，时间复杂度降到了\(O(log n)\)</p>

<h2 id="toc_6">扩展: N阶楼梯，每步可走0～m步，求解算法</h2>

<p>从每步1～2级阶梯到1～m级阶梯，需要改变的不仅仅只是步长，还有每步走完之后，对剩余台阶总数的判断。当当总剩余的台阶数n大于步长m的时候，则第一步为1～m的一个数值，循环递归求解可能的走法。如果总剩余台阶数n小于步长m的时候，则步长调整为n，递归求解。<br/>
具体代码如下: </p>

<pre><code class="language-java">public class Solution {
    @param n: 总的台阶数
    @param m: 每次可以走的最大的阶数
    @return: 一共有多少种可能的走法
    public int climbStairs(int n, int m) {
        int stepsCount = 0;
        // 台阶数为0的时候表示已经走完
        if (n == 0) {
            return 1;
        }
        // 当总剩余的台阶数n大于步长m的时候，则 
        // 第一步为 1～m的一个数值，循环递归求解可能的走法
        if (n &gt;= m) {
            for (int i = 1; i &lt;= m; i++) {
                stepsCount += climbStairs(n-i, m);
            }
        }else { 
        // 如果总剩余台阶数n小于步长m的时候，则 步长为n，递归求解。
            stepsCount += climbStairs(n, n);
        }
        return stepsCount;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从二叉查找树到红黑树]]></title>
    <link href="https://blog.crayygy.com/14584879845645.html"/>
    <updated>2016-03-20T23:33:04+08:00</updated>
    <id>https://blog.crayygy.com/14584879845645.html</id>
    <content type="html"><![CDATA[
<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。但是，在最优情况下和最坏情况下，二叉查找树的性能差异非常的大，因此我们需要一种更优化的方式实现二叉树，红黑树闪亮登场。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">本文目录</h2>

<ul>
<li>
<a href="#toc_0">本文目录</a>
</li>
<li>
<a href="#toc_1">一、二叉查找树（BST）Wiki</a>
</li>
<li>
<a href="#toc_2">二、2-3查找树 Wiki</a>
<ul>
<li>
<a href="#toc_3">2-3查找树的性质</a>
</li>
<li>
<a href="#toc_4">2-3查找树中的查找</a>
</li>
<li>
<a href="#toc_5">2-3查找树中的插入</a>
<ul>
<li>
<a href="#toc_6">1. 向2-结点插入新键</a>
</li>
<li>
<a href="#toc_7">2. 向一棵只含有3-结点的树中插入新键</a>
</li>
<li>
<a href="#toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</a>
</li>
<li>
<a href="#toc_10">5. 分解根结点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">小结</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">三、红黑树 Wiki</a>
<ul>
<li>
<a href="#toc_13">红黑树的性质</a>
</li>
<li>
<a href="#toc_14">红黑树中的变换</a>
<ul>
<li>
<a href="#toc_15">1. 旋转</a>
</li>
<li>
<a href="#toc_16">2. 颜色变化</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">红黑树中的插入</a>
<ul>
<li>
<a href="#toc_18">向单个的2-结点插入新键</a>
</li>
<li>
<a href="#toc_19">向一棵双键树(即一个3-结点)中插入新键</a>
</li>
<li>
<a href="#toc_20">插入算法的实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">红黑树中的查找</a>
</li>
<li>
<a href="#toc_22">红黑树中的删除</a>
</li>
<li>
<a href="#toc_23">红黑树评价</a>
</li>
</ul>
</li>
<li>
<a href="#toc_24">总结</a>
</li>
</ul>


<h2 id="toc_1">一、二叉查找树（BST）<a href="https://en.wikipedia.org/wiki/Binary_search_tree">Wiki</a></h2>

<p>作为常用的数据结构之一，二叉查找树具有非常好的查找、插入时间复杂度。二叉查找树的基本规则是：</p>

<ol>
<li>非空情况下，左结点及其子结点均小于父结点，右结点及其子结点均大于父结点</li>
<li>任意一个结点的左子结点和右子结点均是二叉查找树</li>
<li>没有两个值相等的结点</li>
</ol>

<p>二叉查找树B中查找值x的查找逻辑为：</p>

<ol>
<li>若B是空树，则搜索失败，否则：</li>
<li>若x等于根结点的值，则返回根结点；</li>
<li>若x小于根结点的值，则在左子树中搜索</li>
<li>否则，在右子树中搜索。</li>
</ol>

<p>这是个递归调用的过程(循环也可以实现)</p>

<p>二叉查找树的实现非常的简洁，但是，在最坏情况下，BST的查询时间复杂度为O(n)，即从父结点开始，所有结点均只有左子结点或者右子结点(如图1)，因此，对二叉查找树进行适当的补充修改，让它能够自动平衡树的高度，就可以实现最坏情况下也有O(log n)的时间复杂度。</p>

<p><img src="media/14584879845645/14585680661674.jpg" alt=""/></p>

<h2 id="toc_2">二、2-3查找树 <a href="https://en.wikipedia.org/wiki/2%E2%80%933_tree">Wiki</a></h2>

<h3 id="toc_3">2-3查找树的性质</h3>

<p>2-3查找树的特点是，一个结点可能具有两个子链接，也有可能具有三个子链接，取决于这个结点是2-结点还是3-结点。如图2所示。<br/>
<img src="media/14584879845645/14585758076941.jpg" alt=""/></p>

<p>可以看到，这里面所有的空链接到根结点的距离相等。在2-结点中，左结点均小于父结点，右结点均大于父结点，在3-结点中，左边值小于右边值，左结点小于左边值，右结点大于右边值，中间结点处于两值中间。</p>

<h3 id="toc_4">2-3查找树中的查找</h3>

<p>在2-3查找树中的查找与普通的二叉查找树类似，在树T中查找值x，首先x与根结点的值比较，若等于则直接返回，若小于则在左结点中查找，若大于则在右结点中查找，如果是个3-结点，则比较与左右两个值的大小，小于左值，则左子树，大于右值则右子树，大于左值小于右值则在中间结点中寻找。</p>

<h3 id="toc_5">2-3查找树中的插入</h3>

<p>在2-3查找树中的插入分成几种不同的情况：</p>

<h4 id="toc_6">1. 向2-结点插入新键</h4>

<p>如果插入的结点是一个2-结点，那么将这个结点升级成为3-结点即可(如图3)。<br/>
<img src="media/14584879845645/14587468453810.jpg" alt=""/></p>

<h4 id="toc_7">2. 向一棵只含有3-结点的树中插入新键</h4>

<p><img src="media/14584879845645/14587488829621.jpg" alt=""/></p>

<h4 id="toc_8">3. 向一棵父结点为2-结点的3-结点中插入新键</h4>

<p>这里的重点在于，插入了结点Z，之后，SX结点从3-结点变为4-结点，然后分裂成两个2-结点，将中间值X上浮到R，R所在2-结点编程3-结点，最后形成图5中的模式。<br/>
<img src="media/14584879845645/14587489097083.jpg" alt=""/></p>

<h4 id="toc_9">4. 向一棵父结点为3-结点的3-结点中插入新键</h4>

<p>向父结点为3-结点的3-结点中插入新键与上一个类似，但是需要经过多次的结点升级-&gt;裂变，因此最后构成的2-3查找树，依然是上图中的形式。</p>

<h4 id="toc_10">5. 分解根结点</h4>

<p>当根结点是一个4-结点的时候，根结点分裂成为三个2-结点，并且树的高度增加1。如图6所示。<br/>
<img src="media/14584879845645/14587498914851.jpg" alt=""/></p>

<h3 id="toc_11">小结</h3>

<p>在2-3查找树的插入操作中，最重要的是向2-和3-结点中插入结点，在结点升级之后进行的分裂操作，以及向上浮动的操作。几乎所有的插入结点都可以认为是这些操作的组合。<br/>
另外，这些变换均属于局部变换，不影响整棵树的全局有序性和平衡性。任意一个空链接到根结点的深度都是一定的。</p>

<h2 id="toc_12">三、红黑树 <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Wiki</a></h2>

<p>2-3查找树已经基本上实现了比较友好的查询时间复杂度和插入时间复杂度，重点在于如何在代码层面上实现2-3查找树。<br/>
红黑树就是一种非常简洁的实现方式。</p>

<h3 id="toc_13">红黑树的性质</h3>

<p>红黑树的链接分成两种，红链接和黑链接，红链接对应着3-的子结点，黑链接对应着2-的子结点。如图7所示。<br/>
<img src="media/14584879845645/14591302817466.jpg" alt=""/></p>

<p>3-结点 <em>AB</em>，在红黑树中的画法为右上图所示，对于红黑树而言，黑链接的深度为1，红链接的深度为0，因此可以将红链接拉平，即右下图的画法。可以看到，红黑树的红链接就是将2-3查找树中的3-结点的两个相邻结点之间用红链接来连接，在其他性质上几乎完全相同，因此，实现红黑树的算法与2-3查找树类似，如插入结点时需要用到的旋转操作等。</p>

<p>后面的实现均使用Java语言。</p>

<p>需要注意的特征有:</p>

<ol>
<li>红链接均为左链接</li>
<li>没有任何一个结点同时和两个红链接相连</li>
<li>红黑树是黑链接完美平衡的，即，任意空链接到根结点的路径上的黑链接数量相同。</li>
</ol>

<p>size()方法代码如下:</p>

<pre><code class="language-java">    public int size(){
        return size(root);
    }

    private int size(Node x) {
        if (x==null) {
            return 0;
        }
        return x.N;
    }
</code></pre>

<h3 id="toc_14">红黑树中的变换</h3>

<h4 id="toc_15">1. 旋转</h4>

<p>旋转有几种可能性，一是某结点的右链接(即右结点)为红色，我们需要将它旋转到左侧，二是将一个结点向右旋转。即，我们需要完成两个方法 rotateLeft()和rotateRight(),两个方法本身没有什么关联性，左旋转的代码和右旋转的代码只需要改变其中的right 和left即可。<br/>
代码如下:</p>

<pre><code class="language-java">    // 左旋转
    Node rotateLeft(Node h){
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
    // 右旋转
    Node rotateRight (Node h){
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }
</code></pre>

<h4 id="toc_16">2. 颜色变化</h4>

<p>当一个结点同时连接两个红链接的时候，我们使用flipColors()方法来转换颜色。除了将子结点的颜色由红变黑外，还需要将父结点的颜色由黑变红。</p>

<pre><code class="language-java">    void flipColor(Node h){
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
</code></pre>

<p>另外，我们需要保证，根结点永远是黑色结点，因此在根结点为红色的时候需要进行上浮，并且树的高度增加一。</p>

<h3 id="toc_17">红黑树中的插入</h3>

<p>我们使用RED 和 BLACK 两个bool变量来标志结点的颜色，以此为链接的颜色。使用私有方法isRed()来测试一个结点和父结点之间的颜色。可以获得以下代码(在<code>RedBlackBST</code>类中):</p>

<pre><code class="language-java">    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node {
        Key key;
        Value val;
        Node left, right;
        int N;
        boolean color;

        Node(Key key, Value val, int N, boolean color){
            this.key = key;
            this.val = val;
            this.N = N;
            this.color = color;
        } 
    }

    private boolean isRed(Node x){
        if (x==null) {
            return false;
        }
        return x.color == RED;
    }
</code></pre>

<p>和2-3查找树一样，插入分为几种可能，即向2-和3-结点插入的不同。</p>

<h4 id="toc_18">向单个的2-结点插入新键</h4>

<p>一棵只有一个键的红黑树只有一个2-结点，因此，插入了一个键之后，我们需要旋转来平衡这棵树。</p>

<ol>
<li>如果新键小于旧键，则在左侧新增一个红色结点即可，新的红黑树与单个的3-结点等价。</li>
<li>如果新键大于旧键，则在右侧新增一个红色结点，然后右旋转来保证满足我们对红黑树的约束，即使用 <code>root = rotateRight(root)</code>，来将其旋转为左红链接并且修正根结点的链接，这样才算完整的完成了插入操作。</li>
<li>如果新键等于旧键，则更新旧键的值。</li>
</ol>

<p>不管是如何插入，除了更新结点外，另外两个操作最后都生成了一棵和单个的3-结点等价的红黑树，其中有两个键，左连接为红链接，树的黑链接高度为1。</p>

<h4 id="toc_19">向一棵双键树(即一个3-结点)中插入新键</h4>

<p>同样的，这种情况分为3种子情况，即新键的值与两个旧键的比较。小于两者，两者中间，大于两者。</p>

<ol>
<li>新键大于两个旧键，插入到右结点，此时这棵树是平衡的，根结点是中间大小的键，此时会产生一个具有两个红链接的父结点，此时我们将两个红结点通过颜色变换成黑色，即得到一棵由三个结点组成的高度为2的平衡树，正好能对应一棵2-3树。</li>
<li>新键小于两个旧键，新键会被建立为左结点，同样的产生了两个连续的红链接，此时只需要将上层的红链接通过右旋转即可得到第一种情况。</li>
<li>新键处于两者中间。同样的会产生两个连续的红链接，一个红色链接接一条红色右链接。将下层的红链接左旋转，即可得到第二种情况。</li>
</ol>

<p>如下图(图8)所示。<br/>
<img src="media/14584879845645/14592345345364.jpg" alt=""/></p>

<h4 id="toc_20">插入算法的实现</h4>

<pre><code class="language-java">    public void put(Key key, Value val){
        root = put(root, key, val);
        root.color = BLACK;
    }

    private Node put(Node h, Key key, Value val){
        if (h==null) {
            return new Node(key, val,1,RED);
        }
        int cmp = Key.compareTo(h.key);
        if (cmp &lt; 0) {
            h.left = put(h.left, key, val);
        }else if (cmp &gt; 0) {
            h.right = put(h.right, key, val);
        }else {
            h.val = val;
        }

        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }

        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
</code></pre>

<h3 id="toc_21">红黑树中的查找</h3>

<p>红黑树中的查找与一般的二叉查找树的查找方法完全相同。<br/>
get()方法代码如下:</p>

<pre><code class="language-java">    public Value get(Key key) {
        return get(root, key);
    }

    private Value get(Node x, Key key) {
        if(x == null) return null;
        int cmp = Key.compareTo(x.key);
        if(cmp &lt; 0) return get(x.left, key);
        else if(cmp = 0) return get(x.right, key);
        else return x.val;
    }
</code></pre>

<h3 id="toc_22">红黑树中的删除</h3>

<p>红黑树中的删除操作也是比较的复杂，直接上代码。</p>

<pre><code class="language-java">    private Node moveRedLeft(Node h) {
        // h is RED, h.left &amp; h.left.left is BLACK
        // turn h.left or one child of h.left RED
        flipColor(h);
        if (isRed(h.right.left)) {
            h.right = rotateRight(h.right);
            h.rotateLeft(h);
        }
    }

    public void deleteMin() {
        if (!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMin(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMin(Node h) {
        if (h.left == null) {
            return null;
        }
        if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) {
            h = moveRedLeft(h);
        }
        h.left = deleteMin(h.left);
        return balance(h);
    }

    private void balance(){
        if (isRed(h.right)) {
            h = rotateLeft(h);
        }
        if (isRed(h.right) &amp;&amp; !isRed(h.left)) {
            h = rotateLeft(h);
        }else if (isRed(h.left) &amp;&amp; isRed(h.left.left)) {
            h = rotateRight(h);
        }else (isRed(h.left) &amp;&amp; isRed(h.right)) {
            flipColor(h);
        }
    }

    private Node moveRedRight(Node h) {
        // h is RED, h.right and h.right.left is BLACK
        // turn h.right or one child of h.right RED
        flipColor(h);
        if (!isRed(h.left.left)) {
            h= rotateRight(h);
        }
        return h;
    }

    public void deleteMax() {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = deleteMax(root);
        if(!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMax(Node h) {
        if (isRed(h.left)) {
            h = rotateRight(h);
        }
        if (h.right == null) {
            return null;
        }
        if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
            h = moveRedRight(h);
        }
        h.right = deleteMax(h.right);
        return balance(h);
    }


    public void delete(Key key) {
        if(!isRed(root.left) &amp;&amp; !isRed(root.right)) {
            root.color = RED;
        }
        root = delete(root.key);
        if(isEmpty(root)) root.color = BLACK;
    }

    private void delete(Node h, Key key) {
        if(key.compareTo(h.key) &lt; 0) {
            if( !isRed(h.left) &amp;&amp; !isRed(h.left.left) ) {
                h = moveRedLeft(h);
            }
            h.left = delete(h.left, key);
        } else {
            if (isRed(h.left)) {
                h = rotateRight(h);
            }
            if (key.compareTo(h.key) == 0 &amp;&amp; h.right == null) {
                return null;
            }
            if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) {
                h= moveRedRight(h);
            }
            if (key.compareTo(h.key) == 0) {
                h.val = get(h.right, min(h.right).key)
                h.key = min(h.right).key;
                h.right = deleteMin(h.right);
            } else {
                h.right = delete(h.right, key);
            }
        }
        return balance(h);
    }

</code></pre>

<h3 id="toc_23">红黑树评价</h3>

<p>红黑树是一棵几乎完美平衡的树，无论键的插入顺序如何，总能得到稳定的结果，在时间复杂度上也达到了非常高的效率，而在空间复杂度上，仅在二叉查找树的每个结点上增加了一个标注颜色的布尔变量，没有增加非常多的消耗，在查找上与二叉查找树最优情况完全相同(O(log n)), 在插入操作上增加了一些旋转操作等。<br/>
并且，红黑树本质上还是一棵二叉查找树，因此二叉查找树中用到的rank(), floor(), ceiling()等方法可以不经过任何修改就可以直接使用。</p>

<h2 id="toc_24">总结</h2>

<p>首先，从简洁性上看，二叉树明显是最简单的实现方式，对于查找在最优情况下也可以实现O(log n)的复杂度，然而比较严重的问题是，如果构建这棵树时选择的根结点不是很合理，那么整棵树有可能发生严重的倾斜(最坏情况下为O(n))，如图1。因此，在二叉查找树的基础上，产生了2-3查找树。</p>

<p>2-3查找树最重要的特征是，在3-结点上插入而生成的4-结点会进行分裂，保证了2-3树的平衡性。</p>

<p>在此基础上实现了红黑树，在保持了二叉树的结构的情况下，大幅度优化了插入算法，虽然在实现上稍微复杂了一些，但能保证插入之后的树始终是一棵黑色平衡的树，因此也保证了二叉树的查询复杂度始终为O(log n)，并且不影响其它的操作。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的深度问题]]></title>
    <link href="https://blog.crayygy.com/14591320972722.html"/>
    <updated>2016-03-28T10:28:17+08:00</updated>
    <id>https://blog.crayygy.com/14591320972722.html</id>
    <content type="html"><![CDATA[
<p>昨天笔试的时候做到了一题求二叉树深度的问题，刚刚在Leetcode上刷题的时候刚好也遇到了，就顺手刷了。但是仔细思考发现，这个问题背后所反应的思想很值得我注重，因此写了这篇文章。</p>

<span id="more"></span><!-- more -->

<p>这个算法并不难，利用递归可以非常简单的求解。因此我在看到题目之后，给出的第一个解法是这样的(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int depth = 0;
        if(root.left != null &amp;&amp; root.right != null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = (l &gt; r? l : r) + 1;
        } else if (root.left == null){
            depth = maxDepth(root.right) + 1;
        } else if (root.right == null){
            depth = maxDepth(root.left) + 1;
        } else {
            depth = 0;
        }
        return depth;
    }
}

</code></pre>

<p><img src="media/14591320972722/14591324511074.jpg" alt=""/></p>

<p>解法是没有错误的，并且Leetcode上也是直接Accept了，但总是看起来让人觉得这个代码非常的丑，太杂乱了。</p>

<p>因此我又花了一点时间思考如何优化这段代码，让它看起来不至于这么的复杂。<br/>
在这个代码中，复杂的部分全部在 if-else代码块中，那么是不是可以通过其他的方式来取消掉这些判断呢？</p>

<p>答案是肯定的。因此有了下面的代码(Java版本):</p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        
        int lDepth = maxDepth(root.left);
        int rDepth = maxDepth(root.right);
        
        return lDepth &gt; rDepth? lDepth + 1 : rDepth + 1;
    }
}
</code></pre>

<p><img src="media/14591320972722/14591326336170.jpg" alt=""/></p>

<p>可以看到，时间复杂度几乎没有变化，但是从直观上，第二段代码比之之前的版本，代码非常的简洁，并且让人一眼就能看懂意思。</p>

<p>很不幸，在笔试的时候我用的是第一段代码，并且没有考虑到优化和精简问题，不知道这个是否有影响。</p>

<p>对我而言，这两段代码给我的启发是巨大的。同样的效率的代码，如何能写的更漂亮，让别人看起来更舒服，也很重要。</p>

<p>希望以后能够多注意类似的问题，不再犯同样的错误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人博客搭建完毕]]></title>
    <link href="https://blog.crayygy.com/14582820943493.html"/>
    <updated>2016-03-18T14:21:34+08:00</updated>
    <id>https://blog.crayygy.com/14582820943493.html</id>
    <content type="html"><![CDATA[
<p>纠结了很久，终于这次把博客平台都给弄好了。<br/>
想想还是写点东西，给自己留个念想。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">服务商选择</h3>

<p>之前一直在动态博客和静态博客中纠结。但我是个不喜欢折腾的人，所以Hexo和Jekyll我都不是很喜欢，配置起来实在是有些麻烦。而Wordpress这类的动态博客又需要去自己搭建一个虚拟主机，或者去购买一个主机空间，也是比较的麻烦。索性，直接使用MWeb自带的站点功能，主题什么的我也不是很在意，就这样也挺不错。<br/>
世界上最好用的免费博客空间是什么？ 当然是Github Pages了。用MWeb生成的静态文件，直接通过git提交到Github的仓库中，便实现了静态博客的功能，评论用了多说，也挺好的。昨天刚好看到一个网友用Coding.net 和 Github Pages 加上Dnspod实现了国内外分流。于是索性也加上了Coding的Pages服务，感觉似乎也挺好的，这样blog.crayygy.com等于是拥有了两个备份，即使其中一个除了问题，我相信Dnspod也可以帮我搞定。</p>

<h3 id="toc_1">博客的内容</h3>

<p>之前也零零散散写过一些文章，要么是一些无聊的心情文字，要么就是些烂大街的教程或者评测，没什么太多意义。这次开始写博客，我想从最近开始学习的一些技术上开始入手，比如，马上就要开始学习Django和Android开发，在开发过程中必然也会遇到一些这样那样的问题，把学习过程中遇到的这样那样的问题总结一些，写一写自己的感受。</p>

<p>今天偶然间发现，SegmentFault也有写博客的功能，不过暂时还不打算去写，等到自己的文字有一定的质量的时候再转一些过去吧。</p>

<h3 id="toc_2">给自己的约定</h3>

<p>争取每周都能写一篇技术博客，一点点成长。</p>

<h4 id="toc_3">希望我能如博客名称一般，渐行渐远，哪怕走的很缓慢。</h4>

]]></content>
  </entry>
  
</feed>
